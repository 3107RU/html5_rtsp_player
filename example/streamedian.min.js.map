{"version":3,"file":null,"sources":["../node_modules/bp_logger/logger.js","../node_modules/bp_logger/logger.js","../node_modules/bp_event/event.js","../src/core/iso-bmff/mp4-generator.js","../src/core/util/binary.js","../src/core/remuxer/remuxer.js","../node_modules/bp_statemachine/statemachine.js","../src/core/util/md5.js","../src/client/rtsp/session.js","../src/client/rtsp/client.js","../node_modules/jsencrypt/lib/asn1js/asn1.js","../node_modules/jsencrypt/lib/jsbn/prng4.js","../node_modules/jsencrypt/lib/jsbn/jsbn.js","../node_modules/jsencrypt/lib/asn1js/base64.js","../node_modules/jsencrypt/lib/asn1js/hex.js","../src/media_error.js","../src/player.js","../src/client/rtsp/client.js"],"sourcesContent":["// ERROR=0, WARN=1, LOG=2, DEBUG=3\nexport const LogLevel = {\n    Error: 0,\n    Warn: 1,\n    Log: 2,\n    Debug: 3\n};\n\nlet DEFAULT_LOG_LEVEL = LogLevel.Debug;\n\nexport function setDefaultLogLevel(level) {\n    DEFAULT_LOG_LEVEL = level;\n}\nexport class Logger {\n    constructor(level = DEFAULT_LOG_LEVEL, tag) {\n        this.tag = tag;\n        this.setLevel(level);\n    }\n    \n    setLevel(level) {\n        this.level = level;\n    }\n    \n    static get level_map() { return {\n        [LogLevel.Debug]:'log',\n        [LogLevel.Log]:'log',\n        [LogLevel.Warn]:'warn',\n        [LogLevel.Error]:'error'\n    }};\n\n    _log(lvl, args) {\n        args = Array.prototype.slice.call(args);\n        if (this.tag) {\n            args.unshift(`[${this.tag}]`);\n        }\n        if (this.level>=lvl) console[Logger.level_map[lvl]].apply(console, args);\n    }\n    log(){\n        this._log(LogLevel.Log, arguments)\n    }\n    debug(){\n        this._log(LogLevel.Debug, arguments)\n    }\n    error(){\n        this._log(LogLevel.Error, arguments)\n    }\n    warn(){\n        this._log(LogLevel.Warn, arguments)\n    }\n}\n\nconst taggedLoggers = new Map();\nexport function getTagged(tag) {\n    if (!taggedLoggers.has(tag)) {\n        taggedLoggers.set(tag, new Logger(DEFAULT_LOG_LEVEL, tag));\n    }\n    return taggedLoggers.get(tag);\n}\nexport const Log = new Logger();\n","// ERROR=0, WARN=1, LOG=2, DEBUG=3\nexport const LogLevel = {\n    Error: 0,\n    Warn: 1,\n    Log: 2,\n    Debug: 3\n};\n\nlet DEFAULT_LOG_LEVEL = LogLevel.Debug;\n\nexport function setDefaultLogLevel(level) {\n    DEFAULT_LOG_LEVEL = level;\n}\nexport class Logger {\n    constructor(level = DEFAULT_LOG_LEVEL, tag) {\n        this.tag = tag;\n        this.setLevel(level);\n    }\n    \n    setLevel(level) {\n        this.level = level;\n    }\n    \n    static get level_map() { return {\n        [LogLevel.Debug]:'log',\n        [LogLevel.Log]:'log',\n        [LogLevel.Warn]:'warn',\n        [LogLevel.Error]:'error'\n    }};\n\n    _log(lvl, args) {\n        args = Array.prototype.slice.call(args);\n        if (this.tag) {\n            args.unshift(`[${this.tag}]`);\n        }\n        if (this.level>=lvl) console[Logger.level_map[lvl]].apply(console, args);\n    }\n    log(){\n        this._log(LogLevel.Log, arguments)\n    }\n    debug(){\n        this._log(LogLevel.Debug, arguments)\n    }\n    error(){\n        this._log(LogLevel.Error, arguments)\n    }\n    warn(){\n        this._log(LogLevel.Warn, arguments)\n    }\n}\n\nconst taggedLoggers = new Map();\nexport function getTagged(tag) {\n    if (!taggedLoggers.has(tag)) {\n        taggedLoggers.set(tag, new Logger(DEFAULT_LOG_LEVEL, tag));\n    }\n    return taggedLoggers.get(tag);\n}\nexport const Log = new Logger();\n","const listener = Symbol(\"event_listener\");\nconst listeners = Symbol(\"event_listeners\");\n\nexport class DestructibleEventListener {\n    constructor(eventListener) {\n        this[listener] = eventListener;\n        this[listeners] = new Map();\n    }\n\n    clear() {\n        if (this[listeners]) {\n            for (let entry of this[listeners]) {\n                for (let fn of entry[1]) {\n                    this[listener].removeEventListener(entry[0], fn);\n                }\n            };\n        }\n        this[listeners].clear();\n    }\n\n    destroy() {\n        this.clear();\n        this[listeners] = null;\n    }\n\n    on(event, selector, fn) {\n        if (fn == undefined) {\n            fn = selector;\n            selector = null;\n        }\n        if (selector) {\n            return this.addEventListener(event, (e) => {\n                if (e.target.matches(selector)) {\n                    fn(e)\n                }\n            });\n        } else {\n            return this.addEventListener(event, fn);\n        }\n    }\n\n    addEventListener(event, fn) {\n        if (!this[listeners].has(event)) {\n            this[listeners].set(event, new Set());\n        }\n        this[listeners].get(event).add(fn);\n        this[listener].addEventListener(event, fn, false);\n        return fn;\n    }\n\n    removeEventListener(event, fn) {\n        this[listener].removeEventListener(event, fn, false);\n        if (this[listeners].has(event)) {\n            //this[listeners].set(event, new Set());\n            let ev = this[listeners].get(event);\n            ev.delete(fn);\n            if (!ev.size) {\n                this[listeners].delete(event);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this[listener]) {\n            this[listener].dispatchEvent(event);\n        }\n    }\n}\n\nexport class EventEmitter {\n    constructor(element=null) {\n        this[listener] = new DestructibleEventListener(element || document.createElement('div'));\n    }\n\n    clear() {\n        if (this[listener]) {\n            this[listener].clear();\n        }\n    }\n\n    destroy() {\n        if (this[listener]) {\n            this[listener].destroy();\n            this[listener] = null;\n        }\n    }\n\n    on(event, selector, fn) {\n        if (this[listener]) {\n            return this[listener].on(event, selector, fn);\n        }\n        return null;\n    }\n\n    addEventListener(event, fn) {\n        if (this[listener]) {\n            return this[listener].addEventListener(event, fn, false);\n        }\n        return null;\n    }\n\n    removeEventListener(event, fn) {\n        if (this[listener]) {\n            this[listener].removeEventListener(event, fn, false);\n        }\n    }\n\n    dispatchEvent(event, data) {\n        if (this[listener]) {\n            this[listener].dispatchEvent(new CustomEvent(event, {detail: data}));\n        }\n    }\n}\n\nexport class EventSourceWrapper {\n    constructor(eventSource) {\n        this.eventSource = eventSource;\n        this[listeners] = new Map();\n    }\n\n    on(event, selector, fn) {\n        if (!this[listeners].has(event)) {\n            this[listeners].set(event, new Set());\n        }\n        let listener = this.eventSource.on(event, selector, fn);\n        if (listener) {\n            this[listeners].get(event).add(listener);\n        }\n    }\n\n    off(event, fn){\n        this.eventSource.removeEventListener(event, fn);\n    }\n\n    clear() {\n        this.eventSource.clear();\n        this[listeners].clear();\n    }\n\n    destroy() {\n        this.eventSource.clear();\n        this[listeners] = null;\n        this.eventSource = null;\n    }\n}\n","/**\r\n * Generate MP4 Box\r\n * got from: https://github.com/dailymotion/hls.js\r\n */\r\n\r\nexport class MP4 {\r\n    static init() {\r\n        MP4.types = {\r\n            avc1: [], // codingname\r\n            avcC: [],\r\n            btrt: [],\r\n            dinf: [],\r\n            dref: [],\r\n            esds: [],\r\n            ftyp: [],\r\n            hdlr: [],\r\n            mdat: [],\r\n            mdhd: [],\r\n            mdia: [],\r\n            mfhd: [],\r\n            minf: [],\r\n            moof: [],\r\n            moov: [],\r\n            mp4a: [],\r\n            mvex: [],\r\n            mvhd: [],\r\n            sdtp: [],\r\n            stbl: [],\r\n            stco: [],\r\n            stsc: [],\r\n            stsd: [],\r\n            stsz: [],\r\n            stts: [],\r\n            tfdt: [],\r\n            tfhd: [],\r\n            traf: [],\r\n            trak: [],\r\n            trun: [],\r\n            trex: [],\r\n            tkhd: [],\r\n            vmhd: [],\r\n            smhd: []\r\n        };\r\n\r\n        var i;\r\n        for (i in MP4.types) {\r\n            if (MP4.types.hasOwnProperty(i)) {\r\n                MP4.types[i] = [\r\n                    i.charCodeAt(0),\r\n                    i.charCodeAt(1),\r\n                    i.charCodeAt(2),\r\n                    i.charCodeAt(3)\r\n                ];\r\n            }\r\n        }\r\n\r\n        var videoHdlr = new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x00, // pre_defined\r\n            0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x56, 0x69, 0x64, 0x65,\r\n            0x6f, 0x48, 0x61, 0x6e,\r\n            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\r\n        ]);\r\n\r\n        var audioHdlr = new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x00, // pre_defined\r\n            0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x53, 0x6f, 0x75, 0x6e,\r\n            0x64, 0x48, 0x61, 0x6e,\r\n            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\r\n        ]);\r\n\r\n        MP4.HDLR_TYPES = {\r\n            'video': videoHdlr,\r\n            'audio': audioHdlr\r\n        };\r\n\r\n        var dref = new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x01, // entry_count\r\n            0x00, 0x00, 0x00, 0x0c, // entry_size\r\n            0x75, 0x72, 0x6c, 0x20, // 'url' type\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x01 // entry_flags\r\n        ]);\r\n\r\n        var stco = new Uint8Array([\r\n            0x00, // version\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x00 // entry_count\r\n        ]);\r\n\r\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\r\n\r\n        MP4.STSZ = new Uint8Array([\r\n            0x00, // version\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x00, // sample_size\r\n            0x00, 0x00, 0x00, 0x00, // sample_count\r\n        ]);\r\n        MP4.VMHD = new Uint8Array([\r\n            0x00, // version\r\n            0x00, 0x00, 0x01, // flags\r\n            0x00, 0x00, // graphicsmode\r\n            0x00, 0x00,\r\n            0x00, 0x00,\r\n            0x00, 0x00 // opcolor\r\n        ]);\r\n        MP4.SMHD = new Uint8Array([\r\n            0x00, // version\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, // balance\r\n            0x00, 0x00 // reserved\r\n        ]);\r\n\r\n        MP4.STSD = new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x01]);// entry_count\r\n\r\n        var majorBrand = new Uint8Array([105,115,111,109]); // isom\r\n        var avc1Brand = new Uint8Array([97,118,99,49]); // avc1\r\n        var minorVersion = new Uint8Array([0, 0, 0, 1]);\r\n\r\n        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\r\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\r\n    }\r\n\r\n    static box(type, ...payload) {\r\n        var size = 8,\r\n            i = payload.length,\r\n            len = i,\r\n            result;\r\n        // calculate the total size we need to allocate\r\n        while (i--) {\r\n            size += payload[i].byteLength;\r\n        }\r\n        result = new Uint8Array(size);\r\n        result[0] = (size >> 24) & 0xff;\r\n        result[1] = (size >> 16) & 0xff;\r\n        result[2] = (size >> 8) & 0xff;\r\n        result[3] = size  & 0xff;\r\n        result.set(type, 4);\r\n        // copy the payload into the result\r\n        for (i = 0, size = 8; i < len; ++i) {\r\n            // copy payload[i] array @ offset size\r\n            result.set(payload[i], size);\r\n            size += payload[i].byteLength;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static hdlr(type) {\r\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\r\n    }\r\n\r\n    static mdat(data) {\r\n        return MP4.box(MP4.types.mdat, data);\r\n    }\r\n\r\n    static mdhd(timescale, duration) {\r\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            0x00, 0x00, 0x00, 0x02, // creation_time\r\n            0x00, 0x00, 0x00, 0x03, // modification_time\r\n            (timescale >> 24) & 0xFF,\r\n            (timescale >> 16) & 0xFF,\r\n            (timescale >>  8) & 0xFF,\r\n            timescale & 0xFF, // timescale\r\n            (duration >> 24),\r\n            (duration >> 16) & 0xFF,\r\n            (duration >>  8) & 0xFF,\r\n            duration & 0xFF, // duration\r\n            0x55, 0xc4, // 'und' language (undetermined)\r\n            0x00, 0x00\r\n        ]));\r\n    }\r\n\r\n    static mdia(track) {\r\n        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\r\n    }\r\n\r\n    static mfhd(sequenceNumber) {\r\n        return MP4.box(MP4.types.mfhd, new Uint8Array([\r\n            0x00,\r\n            0x00, 0x00, 0x00, // flags\r\n            (sequenceNumber >> 24),\r\n            (sequenceNumber >> 16) & 0xFF,\r\n            (sequenceNumber >>  8) & 0xFF,\r\n            sequenceNumber & 0xFF, // sequence_number\r\n        ]));\r\n    }\r\n\r\n    static minf(track) {\r\n        if (track.type === 'audio') {\r\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\r\n        } else {\r\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\r\n        }\r\n    }\r\n\r\n    static moof(sn, baseMediaDecodeTime, track) {\r\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track,baseMediaDecodeTime));\r\n    }\r\n    /**\r\n     * @param tracks... (optional) {array} the tracks associated with this movie\r\n     */\r\n    static moov(tracks, duration, timescale) {\r\n        var\r\n            i = tracks.length,\r\n            boxes = [];\r\n\r\n        while (i--) {\r\n            boxes[i] = MP4.trak(tracks[i]);\r\n        }\r\n\r\n        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(timescale, duration)].concat(boxes).concat(MP4.mvex(tracks)));\r\n    }\r\n\r\n    static mvex(tracks) {\r\n        var\r\n            i = tracks.length,\r\n            boxes = [];\r\n\r\n        while (i--) {\r\n            boxes[i] = MP4.trex(tracks[i]);\r\n        }\r\n        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\r\n    }\r\n\r\n    static mvhd(timescale,duration) {\r\n        var\r\n            bytes = new Uint8Array([\r\n                0x00, // version 0\r\n                0x00, 0x00, 0x00, // flags\r\n                0x00, 0x00, 0x00, 0x01, // creation_time\r\n                0x00, 0x00, 0x00, 0x02, // modification_time\r\n                (timescale >> 24) & 0xFF,\r\n                (timescale >> 16) & 0xFF,\r\n                (timescale >>  8) & 0xFF,\r\n                timescale & 0xFF, // timescale\r\n                (duration >> 24) & 0xFF,\r\n                (duration >> 16) & 0xFF,\r\n                (duration >>  8) & 0xFF,\r\n                duration & 0xFF, // duration\r\n                0x00, 0x01, 0x00, 0x00, // 1.0 rate\r\n                0x01, 0x00, // 1.0 volume\r\n                0x00, 0x00, // reserved\r\n                0x00, 0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x01, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x01, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00, // pre_defined\r\n                0xff, 0xff, 0xff, 0xff // next_track_ID\r\n            ]);\r\n        return MP4.box(MP4.types.mvhd, bytes);\r\n    }\r\n\r\n    static sdtp(track) {\r\n        var\r\n            samples = track.samples || [],\r\n            bytes = new Uint8Array(4 + samples.length),\r\n            flags,\r\n            i;\r\n        // leave the full box header (4 bytes) all zero\r\n        // write the sample table\r\n        for (i = 0; i < samples.length; i++) {\r\n            flags = samples[i].flags;\r\n            bytes[i + 4] = (flags.dependsOn << 4) |\r\n                (flags.isDependedOn << 2) |\r\n                (flags.hasRedundancy);\r\n        }\r\n\r\n        return MP4.box(MP4.types.sdtp, bytes);\r\n    }\r\n\r\n    static stbl(track) {\r\n        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\r\n    }\r\n\r\n    static avc1(track) {\r\n        var sps = [], pps = [], i, data, len;\r\n        // assemble the SPSs\r\n\r\n        for (i = 0; i < track.sps.length; i++) {\r\n            data = track.sps[i];\r\n            len = data.byteLength;\r\n            sps.push((len >>> 8) & 0xFF);\r\n            sps.push((len & 0xFF));\r\n            sps = sps.concat(Array.prototype.slice.call(data)); // SPS\r\n        }\r\n\r\n        // assemble the PPSs\r\n        for (i = 0; i < track.pps.length; i++) {\r\n            data = track.pps[i];\r\n            len = data.byteLength;\r\n            pps.push((len >>> 8) & 0xFF);\r\n            pps.push((len & 0xFF));\r\n            pps = pps.concat(Array.prototype.slice.call(data));\r\n        }\r\n\r\n        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([\r\n                0x01,   // version\r\n                sps[3], // profile\r\n                sps[4], // profile compat\r\n                sps[5], // level\r\n                0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\r\n                0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\r\n            ].concat(sps).concat([\r\n                track.pps.length // numOfPictureParameterSets\r\n            ]).concat(pps))), // \"PPS\"\r\n            width = track.width,\r\n            height = track.height;\r\n        //console.log('avcc:' + Hex.hexDump(avcc));\r\n        return MP4.box(MP4.types.avc1, new Uint8Array([\r\n                0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x01, // data_reference_index\r\n                0x00, 0x00, // pre_defined\r\n                0x00, 0x00, // reserved\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00, // pre_defined\r\n                (width >> 8) & 0xFF,\r\n                width & 0xff, // width\r\n                (height >> 8) & 0xFF,\r\n                height & 0xff, // height\r\n                0x00, 0x48, 0x00, 0x00, // horizresolution\r\n                0x00, 0x48, 0x00, 0x00, // vertresolution\r\n                0x00, 0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x01, // frame_count\r\n                0x12,\r\n                0x62, 0x69, 0x6E, 0x65, //binelpro.ru\r\n                0x6C, 0x70, 0x72, 0x6F,\r\n                0x2E, 0x72, 0x75, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, // compressorname\r\n                0x00, 0x18,   // depth = 24\r\n                0x11, 0x11]), // pre_defined = -1\r\n            avcc,\r\n            MP4.box(MP4.types.btrt, new Uint8Array([\r\n                0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\r\n                0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\r\n                0x00, 0x2d, 0xc6, 0xc0])) // avgBitrate\r\n        );\r\n    }\r\n\r\n    static esds(track) {\r\n        var configlen = track.config.byteLength;\r\n        let data = new Uint8Array(26+configlen+3);\r\n        data.set([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n\r\n            0x03, // descriptor_type\r\n            0x17+configlen, // length\r\n            0x00, 0x01, //es_id\r\n            0x00, // stream_priority\r\n\r\n            0x04, // descriptor_type\r\n            0x0f+configlen, // length\r\n            0x40, //codec : mpeg4_audio\r\n            0x15, // stream_type\r\n            0x00, 0x00, 0x00, // buffer_size\r\n            0x00, 0x00, 0x00, 0x00, // maxBitrate\r\n            0x00, 0x00, 0x00, 0x00, // avgBitrate\r\n\r\n            0x05, // descriptor_type\r\n            configlen\r\n        ]);\r\n        data.set(track.config, 26);\r\n        data.set([0x06, 0x01, 0x02], 26+configlen);\r\n        // return new Uint8Array([\r\n        //     0x00, // version 0\r\n        //     0x00, 0x00, 0x00, // flags\r\n        //\r\n        //     0x03, // descriptor_type\r\n        //     0x17+configlen, // length\r\n        //     0x00, 0x01, //es_id\r\n        //     0x00, // stream_priority\r\n        //\r\n        //     0x04, // descriptor_type\r\n        //     0x0f+configlen, // length\r\n        //     0x40, //codec : mpeg4_audio\r\n        //     0x15, // stream_type\r\n        //     0x00, 0x00, 0x00, // buffer_size\r\n        //     0x00, 0x00, 0x00, 0x00, // maxBitrate\r\n        //     0x00, 0x00, 0x00, 0x00, // avgBitrate\r\n        //\r\n        //     0x05 // descriptor_type\r\n        // ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\r\n        return data;\r\n    }\r\n\r\n    static mp4a(track) {\r\n        var audiosamplerate = track.audiosamplerate;\r\n        return MP4.box(MP4.types.mp4a, new Uint8Array([\r\n                0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x00, 0x00, // reserved\r\n                0x00, 0x01, // data_reference_index\r\n                0x00, 0x00, 0x00, 0x00,\r\n                0x00, 0x00, 0x00, 0x00, // reserved\r\n                0x00, track.channelCount, // channelcount\r\n                0x00, 0x10, // sampleSize:16bits\r\n                0x00, 0x00, // pre_defined\r\n                0x00, 0x00, // reserved2\r\n                (audiosamplerate >> 8) & 0xFF,\r\n                audiosamplerate & 0xff, //\r\n                0x00, 0x00]),\r\n            MP4.box(MP4.types.esds, MP4.esds(track)));\r\n    }\r\n\r\n    static stsd(track) {\r\n        if (track.type === 'audio') {\r\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\r\n        } else {\r\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\r\n        }\r\n    }\r\n\r\n    static tkhd(track) {\r\n        var id = track.id,\r\n            duration = track.duration,\r\n            width = track.width,\r\n            height = track.height,\r\n            volume = track.volume;\r\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x07, // flags\r\n            0x00, 0x00, 0x00, 0x00, // creation_time\r\n            0x00, 0x00, 0x00, 0x00, // modification_time\r\n            (id >> 24) & 0xFF,\r\n            (id >> 16) & 0xFF,\r\n            (id >> 8) & 0xFF,\r\n            id & 0xFF, // track_ID\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            (duration >> 24),\r\n            (duration >> 16) & 0xFF,\r\n            (duration >>  8) & 0xFF,\r\n            duration & 0xFF, // duration\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00, // reserved\r\n            0x00, 0x00, // layer\r\n            0x00, 0x00, // alternate_group\r\n            (volume>>0)&0xff, (((volume%1)*10)>>0)&0xff, // track volume // FIXME\r\n            0x00, 0x00, // reserved\r\n            0x00, 0x01, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x01, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x00, 0x00, 0x00, 0x00,\r\n            0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\r\n            (width >> 8) & 0xFF,\r\n            width & 0xFF,\r\n            0x00, 0x00, // width\r\n            (height >> 8) & 0xFF,\r\n            height & 0xFF,\r\n            0x00, 0x00 // height\r\n        ]));\r\n    }\r\n\r\n    static traf(track,baseMediaDecodeTime) {\r\n        var sampleDependencyTable = MP4.sdtp(track),\r\n            id = track.id;\r\n        return MP4.box(MP4.types.traf,\r\n            MP4.box(MP4.types.tfhd, new Uint8Array([\r\n                0x00, // version 0\r\n                0x00, 0x00, 0x00, // flags\r\n                (id >> 24),\r\n                (id >> 16) & 0XFF,\r\n                (id >> 8) & 0XFF,\r\n                (id & 0xFF) // track_ID\r\n            ])),\r\n            MP4.box(MP4.types.tfdt, new Uint8Array([\r\n                0x00, // version 0\r\n                0x00, 0x00, 0x00, // flags\r\n                (baseMediaDecodeTime >>24),\r\n                (baseMediaDecodeTime >> 16) & 0XFF,\r\n                (baseMediaDecodeTime >> 8) & 0XFF,\r\n                (baseMediaDecodeTime & 0xFF) // baseMediaDecodeTime\r\n            ])),\r\n            MP4.trun(track,\r\n                sampleDependencyTable.length +\r\n                16 + // tfhd\r\n                16 + // tfdt\r\n                8 +  // traf header\r\n                16 + // mfhd\r\n                8 +  // moof header\r\n                8),  // mdat header\r\n            sampleDependencyTable);\r\n    }\r\n\r\n    /**\r\n     * Generate a track box.\r\n     * @param track {object} a track definition\r\n     * @return {Uint8Array} the track box\r\n     */\r\n    static trak(track) {\r\n        track.duration = track.duration || 0xffffffff;\r\n        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\r\n    }\r\n\r\n    static trex(track) {\r\n        var id = track.id;\r\n        return MP4.box(MP4.types.trex, new Uint8Array([\r\n            0x00, // version 0\r\n            0x00, 0x00, 0x00, // flags\r\n            (id >> 24),\r\n            (id >> 16) & 0XFF,\r\n            (id >> 8) & 0XFF,\r\n            (id & 0xFF), // track_ID\r\n            0x00, 0x00, 0x00, 0x01, // default_sample_description_index\r\n            0x00, 0x00, 0x00, 0x00, // default_sample_duration\r\n            0x00, 0x00, 0x00, 0x00, // default_sample_size\r\n            0x00, 0x01, 0x00, 0x01 // default_sample_flags\r\n        ]));\r\n    }\r\n\r\n    static trun(track, offset) {\r\n        var samples= track.samples || [],\r\n            len = samples.length,\r\n            arraylen = 12 + (16 * len),\r\n            array = new Uint8Array(arraylen),\r\n            i,sample,duration,size,flags,cts;\r\n        offset += 8 + arraylen;\r\n        array.set([\r\n            0x00, // version 0\r\n            0x00, 0x0f, 0x01, // flags\r\n            (len >>> 24) & 0xFF,\r\n            (len >>> 16) & 0xFF,\r\n            (len >>> 8) & 0xFF,\r\n            len & 0xFF, // sample_count\r\n            (offset >>> 24) & 0xFF,\r\n            (offset >>> 16) & 0xFF,\r\n            (offset >>> 8) & 0xFF,\r\n            offset & 0xFF // data_offset\r\n        ],0);\r\n        for (i = 0; i < len; i++) {\r\n            sample = samples[i];\r\n            duration = sample.duration;\r\n            size = sample.size;\r\n            flags = sample.flags;\r\n            cts = sample.cts;\r\n            array.set([\r\n                (duration >>> 24) & 0xFF,\r\n                (duration >>> 16) & 0xFF,\r\n                (duration >>> 8) & 0xFF,\r\n                duration & 0xFF, // sample_duration\r\n                (size >>> 24) & 0xFF,\r\n                (size >>> 16) & 0xFF,\r\n                (size >>> 8) & 0xFF,\r\n                size & 0xFF, // sample_size\r\n                (flags.isLeading << 2) | flags.dependsOn,\r\n                (flags.isDependedOn << 6) |\r\n                (flags.hasRedundancy << 4) |\r\n                (flags.paddingValue << 1) |\r\n                flags.isNonSync,\r\n                flags.degradPrio & 0xF0 << 8,\r\n                flags.degradPrio & 0x0F, // sample_flags\r\n                (cts >>> 24) & 0xFF,\r\n                (cts >>> 16) & 0xFF,\r\n                (cts >>> 8) & 0xFF,\r\n                cts & 0xFF // sample_composition_time_offset\r\n            ],12+16*i);\r\n        }\r\n        return MP4.box(MP4.types.trun, array);\r\n    }\r\n\r\n    static initSegment(tracks, duration, timescale) {\r\n        if (!MP4.types) {\r\n            MP4.init();\r\n        }\r\n        var movie = MP4.moov(tracks, duration, timescale), result;\r\n        result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\r\n        result.set(MP4.FTYP);\r\n        result.set(movie, MP4.FTYP.byteLength);\r\n        return result;\r\n    }\r\n}\r\n","// TODO: asm.js\r\n\r\nexport function appendByteArray(buffer1, buffer2) {\r\n    let tmp = new Uint8Array((buffer1.byteLength|0) + (buffer2.byteLength|0));\r\n    tmp.set(buffer1, 0);\r\n    tmp.set(buffer2, buffer1.byteLength|0);\r\n    return tmp;\r\n}\r\n\r\nexport function appendByteArrayAsync(buffer1, buffer2) {\r\n    return new Promise((resolve, reject)=>{\r\n        let blob = new Blob([buffer1, buffer2]);\r\n        let reader = new FileReader();\r\n        reader.addEventListener(\"loadend\", function() {\r\n            resolve();\r\n        });\r\n        reader.readAsArrayBuffer(blob);\r\n    });\r\n}\r\nexport function base64ToArrayBuffer(base64) {\r\n    var binary_string =  window.atob(base64);\r\n    var len = binary_string.length;\r\n    var bytes = new Uint8Array( len );\r\n    for (var i = 0; i < len; i++)        {\r\n        bytes[i] = binary_string.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n}\r\n\r\nexport function hexToByteArray(hex) {\r\n    let len = hex.length >> 1;\r\n    var bufView = new Uint8Array(len);\r\n    for (var i = 0; i < len; i++) {\r\n        bufView[i] = parseInt(hex.substr(i<<1,2),16);\r\n    }\r\n    return bufView;\r\n}\r\n\r\nexport function concatenate(resultConstructor, ...arrays) {\r\n    let totalLength = 0;\r\n    for (let arr of arrays) {\r\n        totalLength += arr.length;\r\n    }\r\n    let result = new resultConstructor(totalLength);\r\n    let offset = 0;\r\n    for (let arr of arrays) {\r\n        result.set(arr, offset);\r\n        offset += arr.length;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function bitSlice(bytearray, start=0, end=bytearray.byteLength*8) {\r\n    let byteLen = Math.ceil((end-start)/8);\r\n    let res = new Uint8Array(byteLen);\r\n    let startByte = start >>> 3;   // /8\r\n    let endByte = (end>>>3) - 1;    // /8\r\n    let bitOffset = start & 0x7;     // %8\r\n    let nBitOffset = 8 - bitOffset;\r\n    let endOffset = 8 - end & 0x7;   // %8\r\n    for (let i=0; i<byteLen; ++i) {\r\n        let tail = 0;\r\n        if (i<endByte) {\r\n            tail = bytearray[startByte+i+1] >> nBitOffset;\r\n            if (i == endByte-1 && endOffset < 8) {\r\n                tail >>= endOffset;\r\n                tail <<= endOffset;\r\n            }\r\n        }\r\n        res[i]=(bytearray[startByte+i]<<bitOffset) | tail;\r\n    }\r\n    return res;\r\n}\r\n\r\nexport class BitArray {\r\n\r\n    constructor(src) {\r\n        this.src    = new DataView(src.buffer, src.byteOffset, src.byteLength);\r\n        this.bitpos = 0;\r\n        this.byte   = this.src.getUint8(0); /* This should really be undefined, uint wont allow it though */\r\n        this.bytepos = 0;\r\n    }\r\n\r\n    readBits(length) {\r\n        if (32 < (length|0) || 0 === (length|0)) {\r\n            /* To big for an uint */\r\n            throw new Error(\"too big\");\r\n        }\r\n\r\n        let result = 0;\r\n        for (let i = length; i > 0; --i) {\r\n\r\n            /* Shift result one left to make room for another bit,\r\n             then add the next bit on the stream. */\r\n            result = ((result|0) << 1) | (((this.byte|0) >> (8 - (++this.bitpos))) & 0x01);\r\n            if ((this.bitpos|0)>=8) {\r\n                this.byte = this.src.getUint8(++this.bytepos);\r\n                this.bitpos &= 0x7;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    skipBits(length) {\r\n        this.bitpos += (length|0) & 0x7; // %8\r\n        this.bytepos += (length|0) >>> 3;  // *8\r\n        if (this.bitpos > 7) {\r\n            this.bitpos &= 0x7;\r\n            ++this.bytepos;\r\n        }\r\n\r\n        if (!this.finished()) {\r\n            this.byte = this.src.getUint8(this.bytepos);\r\n            return 0;\r\n        } else {\r\n            return this.bytepos-this.src.byteLength-this.src.bitpos;\r\n        }\r\n    }\r\n    \r\n    finished() {\r\n        return this.bytepos >= this.src.byteLength;\r\n    }\r\n}","import {EventEmitter, EventSourceWrapper} from '../../deps/bp_event.js';\r\nimport {getTagged} from \"../../deps/bp_logger.js\";\r\nimport {MP4} from '../iso-bmff/mp4-generator.js';\r\nimport {AACRemuxer} from './aac.js';\r\nimport {H264Remuxer} from './h264.js';\r\nimport {MSE} from '../presentation/mse.js';\r\nimport {PayloadType} from \"../defs.js\";\r\n\r\nconst LOG_TAG = \"remuxer\";\r\nconst Log = getTagged(LOG_TAG);\r\n\r\nexport class Remuxer {\r\n    static get TrackConverters() {return {\r\n        [PayloadType.H264]: H264Remuxer,\r\n        [PayloadType.AAC]:  AACRemuxer\r\n    }};\r\n\r\n    static get TrackScaleFactor() {return {\r\n        [PayloadType.H264]: 1,//4,\r\n        [PayloadType.AAC]:  0\r\n    }};\r\n\r\n    static get TrackTimescale() {return {\r\n        [PayloadType.H264]: 90000,//22500,\r\n        [PayloadType.AAC]:  0\r\n    }};\r\n\r\n    constructor(mediaElement) {\r\n        this.mse = new MSE([mediaElement]);\r\n        this.eventSource = new EventEmitter();\r\n        this.mseEventSource = new EventSourceWrapper(this.mse.eventSource);\r\n        this.mse_ready = true;\r\n\r\n        this.reset();\r\n\r\n        this.errorListener = this.mseClose.bind(this);\r\n        this.closeListener = this.mseClose.bind(this);\r\n        this.errorDecodeListener = this.mseErrorDecode.bind(this);\r\n\r\n        this.eventSource.addEventListener('ready', this.init.bind(this));\r\n    }\r\n\r\n    initMSEHandlers() {\r\n        this.mseEventSource.on('error', this.errorListener);\r\n        this.mseEventSource.on('sourceclosed', this.closeListener);\r\n        this.mseEventSource.on('errordecode', this.errorDecodeListener);\r\n    }\r\n\r\n    async reset() {\r\n        this.tracks = {};\r\n        this.initialized = false;\r\n        this.initSegments = {};\r\n        this.codecs = [];\r\n        this.streams = {};\r\n        this.enabled = false;\r\n        await this.mse.clear();\r\n        this.initMSEHandlers();\r\n    }\r\n\r\n    destroy() {\r\n        this.mseEventSource.destroy();\r\n        this.mse.destroy();\r\n        this.mse = null;\r\n\r\n        this.detachClient();\r\n\r\n        this.eventSource.destroy();\r\n    }\r\n\r\n    onTracks(tracks) {\r\n        Log.debug(`ontracks: `, tracks.detail);\r\n        // store available track types\r\n        for (let track of tracks.detail) {\r\n            this.tracks[track.type] = new Remuxer.TrackConverters[track.type](Remuxer.TrackTimescale[track.type], Remuxer.TrackScaleFactor[track.type], track.params);\r\n            if (track.offset) {\r\n                this.tracks[track.type].timeOffset = track.offset;\r\n            }\r\n            if (track.duration) {\r\n                this.tracks[track.type].mp4track.duration = track.duration*(this.tracks[track.type].timescale || Remuxer.TrackTimescale[track.type]);\r\n                this.tracks[track.type].duration = track.duration;\r\n            } else {\r\n                this.tracks[track.type].duration = 1;\r\n            }\r\n\r\n            // this.tracks[track.type].duration\r\n        }\r\n        this.mse.setLive(!this.client.seekable);\r\n    }\r\n\r\n    setTimeOffset(timeOffset, track) {\r\n        if (this.tracks[track.type]) {\r\n            this.tracks[track.type].timeOffset = timeOffset;///this.tracks[track.type].scaleFactor;\r\n        }\r\n    }\r\n\r\n    get MSE(){\r\n        return this.mse;\r\n    }\r\n\r\n    init() {\r\n        let tracks = [];\r\n        this.codecs = [];\r\n        let initmse = [];\r\n        let initPts = Infinity;\r\n        let initDts = Infinity;\r\n        for (let track_type in this.tracks) {\r\n            let track = this.tracks[track_type];\r\n            if (!MSE.isSupported([track.mp4track.codec])) {\r\n                throw new Error(`${track.mp4track.type} codec ${track.mp4track.codec} is not supported`);\r\n            }\r\n            tracks.push(track.mp4track);\r\n            this.codecs.push(track.mp4track.codec);\r\n            track.init(initPts, initDts/*, false*/);\r\n            // initPts = Math.min(track.initPTS, initPts);\r\n            // initDts = Math.min(track.initDTS, initDts);\r\n        }\r\n\r\n        for (let track_type in this.tracks) {\r\n            let track = this.tracks[track_type];\r\n            //track.init(initPts, initDts);\r\n            this.initSegments[track_type] = MP4.initSegment([track.mp4track], track.duration*track.timescale, track.timescale);\r\n            initmse.push(this.initMSE(track_type, track.mp4track.codec));\r\n        }\r\n\r\n        this.eventSource.dispatchEvent('mp4initsegement', this.tracks);\r\n        this.initialized = true;\r\n        return Promise.all(initmse).then(()=>{\r\n            //this.mse.play();\r\n            this.enabled = true;\r\n        });\r\n        \r\n    }\r\n\r\n    initMSE(track_type, codec) {\r\n        if (MSE.isSupported(this.codecs)) {\r\n            return this.mse.setCodec(track_type, `${PayloadType.map[track_type]}/mp4; codecs=\"${codec}\"`).then(()=>{\r\n                this.mse.feed(track_type, this.initSegments[track_type]);\r\n                // this.mse.play();\r\n                // this.enabled = true;\r\n            });\r\n        } else {\r\n            throw new Error('Codecs are not supported');\r\n        }\r\n    }\r\n\r\n    mseClose() {\r\n        // this.mse.clear();\r\n        this.client.stop();\r\n        this.eventSource.dispatchEvent('stopped');\r\n    }\r\n\r\n    mseErrorDecode() {\r\n        if(this.tracks[2]) {\r\n            console.warn(this.tracks[2].mp4track.type);\r\n            this.mse.buffers[2].destroy();\r\n            delete this.tracks[2];\r\n        }\r\n    }\r\n\r\n    flush() {\r\n        this.onSamples();\r\n\r\n        if (!this.initialized) {\r\n            // Log.debug(`Initialize...`);\r\n            if (Object.keys(this.tracks).length) {\r\n                for (let track_type in this.tracks) {\r\n                    if (!this.tracks[track_type].readyToDecode || !this.tracks[track_type].samples.length) return;\r\n                    Log.debug(`Init MSE for track ${this.tracks[track_type].mp4track.type}`);\r\n                }\r\n                this.eventSource.dispatchEvent('ready');\r\n            }\r\n        } else {\r\n            for (let track_type in this.tracks) {\r\n                let track = this.tracks[track_type];\r\n                let pay = track.getPayload();\r\n                if (pay && pay.byteLength) {\r\n                    let payload = [MP4.moof(track.seq, track.scaled(track.firstDTS), track.mp4track), MP4.mdat(pay)];\r\n                    this.mse.feed(track_type, payload);\r\n                    this.eventSource.dispatchEvent('mp4payload', payload);\r\n                    track.flush();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    onSamples(ev) {\r\n        // TODO: check format\r\n        // let data = ev.detail;\r\n        // if (this.tracks[data.pay] && this.client.sampleQueues[data.pay].length) {\r\n            // console.log(`video ${data.units[0].dts}`);\r\n        for (let qidx in this.client.sampleQueues) {\r\n            let queue = this.client.sampleQueues[qidx];\r\n            while (queue.length) {\r\n                let units = queue.shift();\r\n                if(units){\r\n                    for (let chunk of units) {\r\n                        if(this.tracks[qidx]) {\r\n                            this.tracks[qidx].remux(chunk);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // }\r\n    }\r\n\r\n    onAudioConfig(ev) {\r\n        if (this.tracks[ev.detail.pay]) {\r\n            this.tracks[ev.detail.pay].setConfig(ev.detail.config);\r\n        }\r\n    }\r\n\r\n    attachClient(client) {\r\n        this.detachClient();\r\n        this.client = client;\r\n        this.clientEventSource = new EventSourceWrapper(this.client.eventSource);\r\n        this.clientEventSource.on('samples', this.samplesListener);\r\n        this.clientEventSource.on('audio_config', this.audioConfigListener);\r\n        this.clientEventSource.on('tracks', this.onTracks.bind(this));\r\n        this.clientEventSource.on('flush', this.flush.bind(this));\r\n        this.clientEventSource.on('clear', ()=>{\r\n            this.reset();\r\n            this.mse.clear().then(()=>{\r\n                //this.mse.play();\r\n                this.initMSEHandlers();\r\n            });\r\n        });\r\n    }\r\n\r\n    detachClient() {\r\n        if (this.client) {\r\n            this.clientEventSource.destroy();\r\n            // this.client.eventSource.removeEventListener('samples', this.onSamples.bind(this));\r\n            // this.client.eventSource.removeEventListener('audio_config', this.onAudioConfig.bind(this));\r\n            // // TODO: clear other listeners\r\n            // this.client.eventSource.removeEventListener('clear', this._clearListener);\r\n            // this.client.eventSource.removeEventListener('tracks', this._tracksListener);\r\n            // this.client.eventSource.removeEventListener('flush', this._flushListener);\r\n            this.client = null;\r\n        }\r\n    }\r\n}","class State {\n    constructor(name, stateMachine) {\n        this.stateMachine = stateMachine;\n        this.transitions = new Set();\n        this.name = name;\n    }\n\n\n    activate() {\n        return Promise.resolve(null);\n    }\n\n    finishTransition() {}\n\n    failHandler() {}\n\n    deactivate() {\n        return Promise.resolve(null);\n    }\n}\n\nexport class StateMachine {\n    constructor() {\n        this.storage = {};\n        this.currentState = null;\n        this.states = new Map();\n    }\n\n    addState(name, {activate, finishTransition, deactivate}) {\n        let state = new State(name, this);\n        if (activate) state.activate = activate;\n        if (finishTransition) state.finishTransition = finishTransition;\n        if (deactivate) state.deactivate = deactivate;\n        this.states.set(name, state);\n        return this;\n    }\n\n    addTransition(fromName, toName){\n        if (!this.states.has(fromName)) {\n            throw ReferenceError(`No such state: ${fromName} while connecting to ${toName}`);\n        }\n        if (!this.states.has(toName)) {\n            throw ReferenceError(`No such state: ${toName} while connecting from ${fromName}`);\n        }\n        this.states.get(fromName).transitions.add(toName);\n        return this;\n    }\n\n    _promisify(res) {\n        let promise;\n        try {\n            promise = res;\n            if (!promise.then) {\n                promise = Promise.resolve(promise);\n            }\n        } catch (e) {\n            promise = Promise.reject(e);\n        }\n        return promise;\n    }\n\n    transitionTo(stateName) {\n        if (this.currentState == null) {\n            let state = this.states.get(stateName);\n            return this._promisify(state.activate.call(this))\n                .then((data)=> {\n                    this.currentState = state;\n                    return data;\n                }).then(state.finishTransition.bind(this)).catch((e)=>{\n                    state.failHandler();\n                    throw e;\n                });\n        }\n        if (this.currentState.name == stateName) return Promise.resolve();\n        if (this.currentState.transitions.has(stateName)) {\n            let state = this.states.get(stateName);\n            return this._promisify(state.deactivate.call(this))\n                .then(state.activate.bind(this)).then((data)=> {\n                    this.currentState = state;\n                    return data;\n                }).then(state.finishTransition.bind(this)).catch((e)=>{\n                    state.failHandler();\n                    throw e;\n                });\n        } else {\n            return Promise.reject(`No such transition: ${this.currentState.name} to ${stateName}`);\n        }\n    }\n\n}\n","/*\r\n * JavaScript MD5\r\n * https://github.com/blueimp/JavaScript-MD5\r\n *\r\n * Copyright 2011, Sebastian Tschan\r\n * https://blueimp.net\r\n *\r\n * Licensed under the MIT license:\r\n * https://opensource.org/licenses/MIT\r\n *\r\n * Based on\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\n\r\n/*\r\n* Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n* to work around bugs in some JS interpreters.\r\n*/\r\nfunction safeAdd(x, y) {\r\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\r\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\r\n    return (msw << 16) | (lsw & 0xFFFF)\r\n}\r\n\r\n/*\r\n* Bitwise rotate a 32-bit number to the left.\r\n*/\r\nfunction bitRotateLeft(num, cnt) {\r\n    return (num << cnt) | (num >>> (32 - cnt))\r\n}\r\n\r\n/*\r\n* These functions implement the four basic operations the algorithm uses.\r\n*/\r\nfunction md5cmn(q, a, b, x, s, t) {\r\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\r\n}\r\nfunction md5ff(a, b, c, d, x, s, t) {\r\n    return md5cmn((b & c) | ((~b) & d), a, b, x, s, t)\r\n}\r\nfunction md5gg(a, b, c, d, x, s, t) {\r\n    return md5cmn((b & d) | (c & (~d)), a, b, x, s, t)\r\n}\r\nfunction md5hh(a, b, c, d, x, s, t) {\r\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\r\n}\r\nfunction md5ii(a, b, c, d, x, s, t) {\r\n    return md5cmn(c ^ (b | (~d)), a, b, x, s, t)\r\n}\r\n\r\n/*\r\n* Calculate the MD5 of an array of little-endian words, and a bit length.\r\n*/\r\nfunction binlMD5(x, len) {\r\n    /* append padding */\r\n    x[len >> 5] |= 0x80 << (len % 32)\r\n    x[(((len + 64) >>> 9) << 4) + 14] = len\r\n\r\n    var i\r\n    var olda\r\n    var oldb\r\n    var oldc\r\n    var oldd\r\n    var a = 1732584193\r\n    var b = -271733879\r\n    var c = -1732584194\r\n    var d = 271733878\r\n\r\n    for (i = 0; i < x.length; i += 16) {\r\n        olda = a\r\n        oldb = b\r\n        oldc = c\r\n        oldd = d\r\n\r\n        a = md5ff(a, b, c, d, x[i], 7, -680876936)\r\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\r\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\r\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\r\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\r\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\r\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\r\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\r\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\r\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\r\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\r\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\r\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\r\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\r\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\r\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\r\n\r\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\r\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\r\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\r\n        b = md5gg(b, c, d, a, x[i], 20, -373897302)\r\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\r\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\r\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\r\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\r\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\r\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\r\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\r\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\r\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\r\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\r\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\r\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\r\n\r\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\r\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\r\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\r\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\r\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\r\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\r\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\r\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\r\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\r\n        d = md5hh(d, a, b, c, x[i], 11, -358537222)\r\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\r\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\r\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\r\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\r\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\r\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\r\n\r\n        a = md5ii(a, b, c, d, x[i], 6, -198630844)\r\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\r\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\r\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\r\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\r\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\r\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\r\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\r\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\r\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\r\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\r\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\r\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\r\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\r\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\r\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\r\n\r\n        a = safeAdd(a, olda)\r\n        b = safeAdd(b, oldb)\r\n        c = safeAdd(c, oldc)\r\n        d = safeAdd(d, oldd)\r\n    }\r\n    return [a, b, c, d]\r\n}\r\n\r\n/*\r\n* Convert an array of little-endian words to a string\r\n*/\r\nfunction binl2rstr(input) {\r\n    var i\r\n    var output = ''\r\n    var length32 = input.length * 32\r\n    for (i = 0; i < length32; i += 8) {\r\n        output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\r\n    }\r\n    return output\r\n}\r\n\r\n/*\r\n* Convert a raw string to an array of little-endian words\r\n* Characters >255 have their high-byte silently ignored.\r\n*/\r\nfunction rstr2binl(input) {\r\n    var i\r\n    var output = []\r\n    output[(input.length >> 2) - 1] = undefined\r\n    for (i = 0; i < output.length; i += 1) {\r\n        output[i] = 0\r\n    }\r\n    var length8 = input.length * 8\r\n    for (i = 0; i < length8; i += 8) {\r\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\r\n    }\r\n    return output\r\n}\r\n\r\n/*\r\n* Calculate the MD5 of a raw string\r\n*/\r\nfunction rstrMD5(s) {\r\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\r\n}\r\n\r\n/*\r\n* Calculate the HMAC-MD5, of a key and some data (raw strings)\r\n*/\r\nfunction rstrHMACMD5(key, data) {\r\n    var i\r\n    var bkey = rstr2binl(key)\r\n    var ipad = []\r\n    var opad = []\r\n    var hash\r\n    ipad[15] = opad[15] = undefined\r\n    if (bkey.length > 16) {\r\n        bkey = binlMD5(bkey, key.length * 8)\r\n    }\r\n    for (i = 0; i < 16; i += 1) {\r\n        ipad[i] = bkey[i] ^ 0x36363636\r\n        opad[i] = bkey[i] ^ 0x5C5C5C5C\r\n    }\r\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\r\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\r\n}\r\n\r\n/*\r\n* Convert a raw string to a hex string\r\n*/\r\nfunction rstr2hex(input) {\r\n    var hexTab = '0123456789abcdef'\r\n    var output = ''\r\n    var x\r\n    var i\r\n    for (i = 0; i < input.length; i += 1) {\r\n        x = input.charCodeAt(i)\r\n        output += hexTab.charAt((x >>> 4) & 0x0F) +\r\n            hexTab.charAt(x & 0x0F)\r\n    }\r\n    return output\r\n}\r\n\r\n/*\r\n* Encode a string as utf-8\r\n*/\r\nfunction str2rstrUTF8(input) {\r\n    return unescape(encodeURIComponent(input))\r\n}\r\n\r\n/*\r\n* Take string arguments and return either raw or hex encoded strings\r\n*/\r\nfunction rawMD5(s) {\r\n    return rstrMD5(str2rstrUTF8(s))\r\n}\r\nfunction hexMD5(s) {\r\n    return rstr2hex(rawMD5(s))\r\n}\r\nfunction rawHMACMD5(k, d) {\r\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\r\n}\r\nfunction hexHMACMD5(k, d) {\r\n    return rstr2hex(rawHMACMD5(k, d))\r\n}\r\n\r\nexport default function md5(string, key, raw) {\r\n    if (!key) {\r\n        if (!raw) {\r\n            return hexMD5(string)\r\n        }\r\n        return rawMD5(string)\r\n    }\r\n    if (!raw) {\r\n        return hexHMACMD5(key, string)\r\n    }\r\n    return rawHMACMD5(key, string)\r\n}\r\n","import {getTagged} from '../../deps/bp_logger.js';\r\n\r\nimport {RTSPClientSM as RTSPClient} from './client.js';\r\nimport {Url} from '../../core/util/url.js';\r\nimport {RTSPError} from \"./client\";\r\n\r\nconst LOG_TAG = \"rtsp:session\";\r\nconst Log = getTagged(LOG_TAG);\r\n\r\nexport class RTSPSession {\r\n\r\n    constructor(client, sessionId) {\r\n        this.state = null;\r\n        this.client = client;\r\n        this.sessionId = sessionId;\r\n        this.url = this.getControlURL();\r\n    }\r\n\r\n    reset() {\r\n        this.client = null;\r\n    }\r\n\r\n    start() {\r\n        return this.sendPlay();\r\n    }\r\n\r\n    stop() {\r\n        return this.sendTeardown();\r\n    }\r\n\r\n    getControlURL() {\r\n        let ctrl = this.client.sdp.getSessionBlock().control;\r\n        if (Url.isAbsolute(ctrl)) {\r\n            return ctrl;\r\n        } else if (!ctrl || '*' === ctrl) {\r\n            return this.client.contentBase;\r\n        } else {\r\n            return `${this.client.contentBase}${ctrl}`;\r\n        }\r\n    }\r\n\r\n    sendRequest(_cmd, _params = {}) {\r\n        let params = {};\r\n        if (this.sessionId) {\r\n            params['Session'] = this.sessionId;\r\n        }\r\n        Object.assign(params, _params);\r\n        return this.client.sendRequest(_cmd, this.getControlURL(), params);\r\n    }\r\n\r\n    async sendPlay(pos = 0) {\r\n        this.state = RTSPClient.STATE_PLAY;\r\n        let params = {};\r\n        let range = this.client.sdp.sessionBlock.range;\r\n        if (range) {\r\n            // TODO: seekable\r\n            if (range[0] == -1) {\r\n                range[0] = 0;// Do not handle now at the moment\r\n            }\r\n            // params['Range'] = `${range[2]}=${range[0]}-`;\r\n        }\r\n        let data = await this.sendRequest('PLAY', params);\r\n        this.state = RTSPClient.STATE_PLAYING;\r\n        return {data: data};\r\n    }\r\n\r\n    async sendPause() {\r\n        if (!this.client.supports(\"PAUSE\")) {\r\n            return;\r\n        }\r\n        this.state = RTSPClient.STATE_PAUSE;\r\n        await this.sendRequest(\"PAUSE\");\r\n        this.state = RTSPClient.STATE_PAUSED;\r\n    }\r\n\r\n    async sendTeardown() {\r\n        if (this.state != RTSPClient.STATE_TEARDOWN) {\r\n            this.state = RTSPClient.STATE_TEARDOWN;\r\n            await this.sendRequest(\"TEARDOWN\");\r\n            Log.log('RTSPClient: STATE_TEARDOWN');\r\n            ///this.client.connection.disconnect();\r\n            // TODO: Notify client\r\n        }\r\n    }\r\n}\r\n","import {getTagged} from '../../deps/bp_logger.js';\r\nimport {StateMachine} from '../../deps/bp_statemachine.js';\r\nimport {SDPParser} from '../../core/parsers/sdp.js';\r\nimport {RTSPStream} from './stream.js';\r\nimport md5 from '../../core/util/md5';\r\n// import {RTP} from './rtp/rtp';\r\nimport RTPFactory from './rtp/factory.js';\r\nimport {MessageBuilder} from './message.js';\r\nimport {RTPPayloadParser} from './rtp/payload/parser.js';\r\nimport {BaseClient} from '../../core/base_client.js';\r\nimport {PayloadType} from '../../core/defs.js';\r\nimport {base64ToArrayBuffer, hexToByteArray} from '../../core/util/binary.js';\r\nimport {AACParser} from '../../core/parsers/aac.js';\r\nimport {RTSPSession} from \"./session\";\r\n\r\nconst LOG_TAG = \"client:rtsp\";\r\nconst Log = getTagged(LOG_TAG);\r\n\r\nexport class RTPError {\r\n    constructor(message, file, line) {\r\n        //super(message, file, line);\r\n    }\r\n}\r\n\r\nexport default class RTSPClient extends BaseClient {\r\n    constructor(options={flush: 200}) {\r\n        super(options);\r\n        this.clientSM = new RTSPClientSM(this);\r\n        this.clientSM.ontracks = (tracks) => {\r\n            this.eventSource.dispatchEvent('tracks', tracks);\r\n            this.startStreamFlush();\r\n        };\r\n        this.sampleQueues={};\r\n    }\r\n    \r\n    static streamType() {\r\n        return 'rtsp';\r\n    }\r\n\r\n    setSource(url) {\r\n        super.setSource(url);\r\n        this.clientSM.setSource(url);\r\n    }\r\n    attachTransport(transport) {\r\n        super.attachTransport(transport);\r\n        this.clientSM.transport = transport;\r\n    }\r\n\r\n    detachTransport() {\r\n        super.detachTransport();\r\n        this.clientSM.transport = null;\r\n    }\r\n\r\n    reset() {\r\n        super.reset();\r\n        this.sampleQueues={};\r\n    }\r\n\r\n    destroy() {\r\n        this.clientSM.destroy();\r\n        return super.destroy();\r\n    }\r\n\r\n    start() {\r\n        super.start();\r\n        if (this.transport) {\r\n            return this.transport.ready.then(() => {\r\n                return this.clientSM.start();\r\n            });\r\n        } else {\r\n            return Promise.reject(\"no transport attached\");\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        super.stop();\r\n        return this.clientSM.stop();\r\n    }\r\n\r\n    onData(data) {\r\n        this.clientSM.onData(data);\r\n    }\r\n\r\n    onConnected() {\r\n        this.clientSM.onConnected();\r\n        super.onConnected();\r\n    }\r\n\r\n    onDisconnected() {\r\n        super.onDisconnected();\r\n        this.clientSM.onDisconnected();\r\n    }\r\n}\r\n\r\nclass AuthError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n    }\r\n}\r\n\r\nexport class RTSPError extends Error {\r\n    constructor(data) {\r\n        super(data.msg);\r\n        this.data = data;\r\n    }\r\n}\r\n\r\nexport class RTSPClientSM extends StateMachine {\r\n    static get USER_AGENT() {return 'SFRtsp 0.3';}\r\n    static get STATE_INITIAL() {return  1 << 0;}\r\n    static get STATE_OPTIONS() {return 1 << 1;}\r\n    static get STATE_DESCRIBE () {return  1 << 2;}\r\n    static get STATE_SETUP() {return  1 << 3;}\r\n    static get STATE_STREAMS() {return 1 << 4;}\r\n    static get STATE_TEARDOWN() {return  1 << 5;}\r\n    static get STATE_PLAY() {return  1 << 6;}\r\n    static get STATE_PLAYING() {return  1 << 7;}\r\n    static get STATE_PAUSE() {return  1 << 8;}\r\n    static get STATE_PAUSED() {return  1 << 9;}\r\n    // static STATE_PAUSED = 1 << 6;\r\n\r\n    constructor(parent) {\r\n        super();\r\n\r\n        this.parent = parent;\r\n        this.transport = null;\r\n        this.payParser = new RTPPayloadParser();\r\n        this.rtp_channels = new Set();\r\n        this.sessions = {};\r\n        this.ontracks = null;\r\n\r\n        this.addState(RTSPClientSM.STATE_INITIAL,{\r\n        }).addState(RTSPClientSM.STATE_OPTIONS, {\r\n            activate: this.sendOptions,\r\n            finishTransition: this.onOptions\r\n        }).addState(RTSPClientSM.STATE_DESCRIBE, {\r\n            activate: this.sendDescribe,\r\n            finishTransition: this.onDescribe\r\n        }).addState(RTSPClientSM.STATE_SETUP, {\r\n            activate: this.sendSetup,\r\n            finishTransition: this.onSetup\r\n        }).addState(RTSPClientSM.STATE_STREAMS, {\r\n\r\n        }).addState(RTSPClientSM.STATE_TEARDOWN, {\r\n            activate: ()=>{\r\n                this.started = false;\r\n            },\r\n            finishTransition: ()=>{\r\n                return this.transitionTo(RTSPClientSM.STATE_INITIAL)\r\n            }\r\n        }).addTransition(RTSPClientSM.STATE_INITIAL, RTSPClientSM.STATE_OPTIONS)\r\n            .addTransition(RTSPClientSM.STATE_INITIAL, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_OPTIONS, RTSPClientSM.STATE_DESCRIBE)\r\n            .addTransition(RTSPClientSM.STATE_DESCRIBE, RTSPClientSM.STATE_SETUP)\r\n            .addTransition(RTSPClientSM.STATE_SETUP, RTSPClientSM.STATE_STREAMS)\r\n            .addTransition(RTSPClientSM.STATE_TEARDOWN, RTSPClientSM.STATE_INITIAL)\r\n            // .addTransition(RTSPClientSM.STATE_STREAMS, RTSPClientSM.STATE_PAUSED)\r\n            // .addTransition(RTSPClientSM.STATE_PAUSED, RTSPClientSM.STATE_STREAMS)\r\n            .addTransition(RTSPClientSM.STATE_STREAMS, RTSPClientSM.STATE_TEARDOWN)\r\n            // .addTransition(RTSPClientSM.STATE_PAUSED, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_SETUP, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_DESCRIBE, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_OPTIONS, RTSPClientSM.STATE_TEARDOWN);\r\n\r\n        this.reset();\r\n\r\n        this.shouldReconnect = false;\r\n\r\n        // TODO: remove listeners\r\n        // this.connection.eventSource.addEventListener('connected', ()=>{\r\n        //     if (this.shouldReconnect) {\r\n        //         this.reconnect();\r\n        //     }\r\n        // });\r\n        // this.connection.eventSource.addEventListener('disconnected', ()=>{\r\n        //     if (this.started) {\r\n        //         this.shouldReconnect = true;\r\n        //     }\r\n        // });\r\n        // this.connection.eventSource.addEventListener('data', (data)=>{\r\n        //     let channel = new DataView(data).getUint8(1);\r\n        //     if (this.rtp_channels.has(channel)) {\r\n        //         this.onRTP({packet: new Uint8Array(data, 4), type: channel});\r\n        //     }\r\n        //\r\n        // });\r\n    }\r\n\r\n    destroy() {\r\n        this.parent = null;\r\n    }\r\n\r\n    setSource(url) {\r\n        this.reset();\r\n        this.endpoint = url;\r\n        this.url = `${url.protocol}://${url.location}${url.urlpath}`;\r\n    }\r\n\r\n    onConnected() {\r\n        if (this.rtpFactory) {\r\n            this.rtpFactory = null;\r\n        }\r\n        if (this.shouldReconnect) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    async onDisconnected() {\r\n        this.reset();\r\n        this.shouldReconnect = true;\r\n        await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n        await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n    }\r\n\r\n    start() {\r\n        if (this.currentState.name !== RTSPClientSM.STATE_STREAMS) {\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        } else {\r\n            // TODO: seekable\r\n            let promises = [];\r\n            for (let session in this.sessions) {\r\n                promises.push(this.sessions[session].sendPlay());\r\n            }\r\n            return Promise.all(promises);\r\n        }\r\n    }\r\n\r\n    onData(data) {\r\n        let channel = data[1];\r\n        if (this.rtp_channels.has(channel)) {\r\n            this.onRTP({packet: data.subarray(4), type: channel});\r\n        }\r\n    }\r\n\r\n    useRTPChannel(channel) {\r\n        this.rtp_channels.add(channel);\r\n    }\r\n\r\n    forgetRTPChannel(channel) {\r\n        this.rtp_channels.delete(channel);\r\n    }\r\n\r\n    stop() {\r\n        this.shouldReconnect = false;\r\n        let promises = [];\r\n        for (let session in this.sessions) {\r\n            promises.push(this.sessions[session].sendPause());\r\n        }\r\n        return Promise.all(promises);\r\n        // this.mse = null;\r\n    }\r\n\r\n    async reset() {\r\n        this.authenticator = '';\r\n        this.methods = [];\r\n        this.tracks = [];\r\n        this.rtpBuffer={};\r\n        for (let stream in this.streams) {\r\n            this.streams[stream].reset();\r\n        }\r\n        for (let session in this.sessions) {\r\n            this.sessions[session].reset();\r\n        }\r\n        this.streams={};\r\n        this.sessions={};\r\n        this.contentBase = \"\";\r\n        if (this.currentState) {\r\n            if (this.currentState.name != RTSPClientSM.STATE_INITIAL) {\r\n                await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n                await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n            }\r\n        } else {\r\n            await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n        }\r\n        this.sdp = null;\r\n        this.interleaveChannelIndex = 0;\r\n        this.session = null;\r\n        this.timeOffset = {};\r\n        this.lastTimestamp = {};\r\n    }\r\n\r\n    async reconnect() {\r\n        //this.parent.eventSource.dispatchEvent('clear');\r\n        await this.reset();\r\n        if (this.currentState.name != RTSPClientSM.STATE_INITIAL) {\r\n            await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        } else {\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        }\r\n    }\r\n\r\n    supports(method) {\r\n        return this.methods.includes(method)\r\n    }\r\n\r\n    parse(_data) {\r\n        Log.debug(_data.payload);\r\n        let d=_data.payload.split('\\r\\n\\r\\n');\r\n        let parsed =  MessageBuilder.parse(d[0]);\r\n        let len = Number(parsed.headers['content-length']);\r\n        if (len) {\r\n            let d=_data.payload.split('\\r\\n\\r\\n');\r\n            parsed.body = d[1];\r\n        } else {\r\n            parsed.body=\"\";\r\n        }\r\n        return parsed\r\n    }\r\n\r\n    sendRequest(_cmd, _host, _params={}, _payload=null) {\r\n        this.cSeq++;\r\n        Object.assign(_params, {\r\n            CSeq: this.cSeq,\r\n            'User-Agent': RTSPClientSM.USER_AGENT\r\n        });\r\n        if (this.authenticator) {\r\n            _params['Authorization'] = this.authenticator(_cmd);\r\n        }\r\n        return this.send(MessageBuilder.build(_cmd, _host, _params, _payload), _cmd).catch((e)=>{\r\n            if ((e instanceof AuthError) && !_params['Authorization'] ) {\r\n                return this.sendRequest(_cmd, _host, _params, _payload);\r\n            } else {\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n\r\n    async send(_data, _method) {\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.ready;\r\n            } catch(e) {\r\n                this.onDisconnected();\r\n                throw e;\r\n            }\r\n            Log.debug(_data);\r\n            let response = await this.transport.send(_data);\r\n            let parsed = this.parse(response);\r\n            // TODO: parse status codes\r\n            if (parsed.code == 401 /*&& !this.authenticator */) {\r\n                Log.debug(parsed.headers['www-authenticate']);\r\n                let auth = parsed.headers['www-authenticate'];\r\n                let method = auth.substring(0, auth.indexOf(' '));\r\n                auth = auth.substr(method.length+1);\r\n                let chunks = auth.split(',');\r\n\r\n                let ep = this.parent.endpoint;\r\n                if (!ep.user || !ep.pass) {\r\n                    try {\r\n                        await this.parent.queryCredentials.call(this.parent);\r\n                    } catch (e) {\r\n                        throw new AuthError();\r\n                    }\r\n                }\r\n\r\n                if (method.toLowerCase() == 'digest') {\r\n                    let parsedChunks = {};\r\n                    for (let chunk of chunks) {\r\n                        let c = chunk.trim();\r\n                        let [k,v] = c.split('=');\r\n                        parsedChunks[k] = v.substr(1, v.length-2);\r\n                    }\r\n                    this.authenticator = (_method)=>{\r\n                        let ep = this.parent.endpoint;\r\n                        let ha1 = md5(`${ep.user}:${parsedChunks.realm}:${ep.pass}`);\r\n                        let ha2 = md5(`${_method}:${this.url}`);\r\n                        let response = md5(`${ha1}:${parsedChunks.nonce}:${ha2}`);\r\n                        let tail=''; // TODO: handle other params\r\n                        return `Digest username=\"${ep.user}\", realm=\"${parsedChunks.realm}\", nonce=\"${parsedChunks.nonce}\", uri=\"${this.url}\", response=\"${response}\"${tail}`;\r\n                    }\r\n                } else {\r\n                    this.authenticator = ()=>{return `Basic ${btoa(this.parent.endpoint.auth)}`;};\r\n                }\r\n\r\n                throw new AuthError(parsed);\r\n            }\r\n            if (parsed.code >= 300) {\r\n                Log.error(parsed.statusLine);\r\n                this.parent.options.errorHandler(new RTSPError({msg: `RTSP error: ${parsed.code} ${parsed.statusLine}`, parsed: parsed}));\r\n            }\r\n            return parsed;\r\n        } else {\r\n            return Promise.reject(\"No transport attached\");\r\n        }\r\n    }\r\n\r\n    sendOptions() {\r\n        this.reset();\r\n        this.started = true;\r\n        this.cSeq = 0;\r\n        return this.sendRequest('OPTIONS', this.url, {});\r\n    }\r\n\r\n    onOptions(data) {\r\n        this.methods = data.headers['public'].split(',').map((e)=>e.trim());\r\n        this.transitionTo(RTSPClientSM.STATE_DESCRIBE);\r\n    }\r\n\r\n    sendDescribe() {\r\n        return this.sendRequest('DESCRIBE', this.url, {\r\n            'Accept': 'application/sdp'\r\n        }).then((data)=>{\r\n            this.sdp = new SDPParser();\r\n            return this.sdp.parse(data.body).catch(()=>{\r\n                throw new Error(\"Failed to parse SDP\");\r\n            }).then(()=>{return data;});\r\n        });\r\n    }\r\n\r\n    onDescribe(data) {\r\n        this.contentBase = data.headers['content-base'] || this.url;// `${this.endpoint.protocol}://${this.endpoint.location}${this.endpoint.urlpath}/`;\r\n        this.tracks = this.sdp.getMediaBlockList();\r\n        this.rtpFactory = new RTPFactory(this.sdp);\r\n\r\n        Log.log('SDP contained ' + this.tracks.length + ' track(s). Calling SETUP for each.');\r\n\r\n        if (data.headers['session']) {\r\n            this.session = data.headers['session'];\r\n        }\r\n\r\n        if (!this.tracks.length) {\r\n            throw new Error(\"No tracks in SDP\");\r\n        }\r\n\r\n        this.transitionTo(RTSPClientSM.STATE_SETUP);\r\n    }\r\n\r\n    sendSetup() {\r\n        let streams=[];\r\n\t\tlet lastPromise = null;\r\n\r\n        // TODO: select first video and first audio tracks\r\n        for (let track_type of this.tracks) {\r\n            Log.log(\"setup track: \"+track_type);\r\n            // if (track_type=='audio') continue;\r\n            // if (track_type=='video') continue;\r\n            let track = this.sdp.getMediaBlock(track_type);\r\n            // If payload type is defined in the specification then \"rtpmap\" may be not specified\r\n            if (!track.rtpmap[track.fmt[0]]) {\r\n                Log.warn(`Pyload type \"${track.fmt[0]}\" is not supported`);\r\n                continue;\r\n            }\r\n\r\n            // If payload type is dynamic then check it encoding name\r\n            if (!PayloadType.string_map[track.rtpmap[track.fmt[0]].name]) {\r\n                Log.warn(`Pyload type \"${track.rtpmap[track.fmt[0]].name}\" is not supported`);\r\n                continue;\r\n            }\r\n\r\n            this.streams[track_type] = new RTSPStream(this, track);\r\n            let setupPromise = this.streams[track_type].start(lastPromise);\r\n            lastPromise = setupPromise;\r\n            this.parent.sampleQueues[PayloadType.string_map[track.rtpmap[track.fmt[0]].name]]=[];\r\n            this.rtpBuffer[track.fmt[0]]=[];\r\n            streams.push(setupPromise.then(({track, data})=>{\r\n                let timeOffset = 0;\r\n                this.timeOffset[track.fmt[0]] = 0;\r\n                try {\r\n                    let rtp_info = data.headers[\"rtp-info\"].split(';');\r\n                    for (let chunk of rtp_info) {\r\n                        let [key, val] = chunk.split(\"=\");\r\n                        if (key === \"rtptime\") {\r\n                            this.timeOffset[track.fmt[0]] = 0;//Number(val);\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // new Date().getTime();\r\n                }\r\n                let params = {\r\n                    timescale: 0,\r\n                    scaleFactor: 0\r\n                };\r\n                if (track.fmtp) {\r\n                    if (track.fmtp['sprop-parameter-sets']) {\r\n                        let sps_pps = track.fmtp['sprop-parameter-sets'].split(',');\r\n                        params = {\r\n                            sps:base64ToArrayBuffer(sps_pps[0]),\r\n                            pps:base64ToArrayBuffer(sps_pps[1])\r\n                        };\r\n                    } else if (track.fmtp['config']) {\r\n                        let config = track.fmtp['config'];\r\n                        this.has_config = track.fmtp['cpresent']!='0';\r\n                        let generic = track.rtpmap[track.fmt[0]].name == 'MPEG4-GENERIC';\r\n                        if (generic) {\r\n                            params={config:\r\n                                AACParser.parseAudioSpecificConfig(hexToByteArray(config))\r\n                            };\r\n                            this.payParser.aacparser.setConfig(params.config);\r\n                        } else if (config) {\r\n                            // todo: parse audio specific config for mpeg4-generic\r\n                            params={config:\r\n                                AACParser.parseStreamMuxConfig(hexToByteArray(config))\r\n                            };\r\n                            this.payParser.aacparser.setConfig(params.config);\r\n                        }\r\n                    }\r\n                }\r\n                params.duration = this.sdp.sessionBlock.range?this.sdp.sessionBlock.range[1]-this.sdp.sessionBlock.range[0]:1;\r\n                this.parent.seekable = (params.duration > 1);\r\n                let res = {\r\n                    track: track,\r\n                    offset: this.timeOffset[track.fmt[0]],\r\n                    type: PayloadType.string_map[track.rtpmap[track.fmt[0]].name],\r\n                    params: params,\r\n                    duration: params.duration\r\n                };\r\n                console.log(res, this.timeOffset);\r\n                let session = data.headers.session.split(';')[0];\r\n                if (!this.sessions[session]) {\r\n                    this.sessions[session] = new RTSPSession(this, session);\r\n                }\r\n                return res;\r\n            }));\r\n        }\r\n        return Promise.all(streams).then((tracks)=>{\r\n            let sessionPromises = [];\r\n            for (let session in this.sessions) {\r\n                sessionPromises.push(this.sessions[session].start());\r\n            }\r\n            return Promise.all(sessionPromises).then(()=>{\r\n                if (this.ontracks) {\r\n                    this.ontracks(tracks);\r\n                }\r\n            })\r\n        }).catch((e)=>{\r\n            console.error(e);\r\n            this.stop();\r\n            this.reset();\r\n        });\r\n    }\r\n\r\n    onSetup() {\r\n        this.transitionTo(RTSPClientSM.STATE_STREAMS);\r\n    }\r\n\r\n    onRTP(_data) {\r\n        if (!this.rtpFactory) return;\r\n\r\n        let rtp = this.rtpFactory.build(_data.packet, this.sdp);\r\n        if (!rtp.type) {\r\n            return;\r\n        }\r\n\r\n        if (this.timeOffset[rtp.pt] === undefined) {\r\n            //console.log(rtp.pt, this.timeOffset[rtp.pt]);\r\n            this.rtpBuffer[rtp.pt].push(rtp);\r\n            return;\r\n        }\r\n\r\n        if (this.lastTimestamp[rtp.pt] === undefined) {\r\n            this.lastTimestamp[rtp.pt] = rtp.timestamp-this.timeOffset[rtp.pt];\r\n        }\r\n\r\n        let queue = this.rtpBuffer[rtp.pt];\r\n        queue.push(rtp);\r\n\r\n        while (queue.length) {\r\n            let rtp = queue.shift();\r\n\r\n            rtp.timestamp = rtp.timestamp-this.timeOffset[rtp.pt]-this.lastTimestamp[rtp.pt];\r\n            // TODO: overflow\r\n            // if (rtp.timestamp < 0) {\r\n            //     rtp.timestamp = (rtp.timestamp + Number.MAX_SAFE_INTEGER) % 0x7fffffff;\r\n            // }\r\n            if (rtp.media) {\r\n                let pay = this.payParser.parse(rtp);\r\n                if (pay) {\r\n                    // if (typeof pay == typeof []) {\r\n                    this.parent.sampleQueues[rtp.type].push(pay);\r\n                    // } else {\r\n                    //     this.parent.sampleQueues[rtp.type].push([pay]);\r\n                    // }\r\n                } else {\r\n                    // this.parent.sampleQueues[rtp.type].push(pay);\r\n                }\r\n            }\r\n        }\r\n        // this.remuxer.feedRTP();\r\n    }\r\n}","// ASN.1 JavaScript decoder\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\n/*global oids */\n\nvar hardLimit = 100,\n    ellipsis = \"\\u2026\",\n    DOM = {\n        tag: function (tagName, className) {\n            var t = document.createElement(tagName);\n            t.className = className;\n            return t;\n        },\n        text: function (str) {\n            return document.createTextNode(str);\n        }\n    };\n\nclass Stream {\n    static get hexDigits() {\n        return \"0123456789ABCDEF\";\n    };\n\n    static get reTime() {\n        return /^((?:1[89]|2\\d)?\\d\\d)(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])([01]\\d|2[0-3])(?:([0-5]\\d)(?:([0-5]\\d)(?:[.,](\\d{1,3}))?)?)?(Z|[-+](?:[0]\\d|1[0-2])([0-5]\\d)?)?$/;\n    }\n\n\n    constructor(enc, pos) {\n        if (enc instanceof Stream) {\n            this.enc = enc.enc;\n            this.pos = enc.pos;\n        } else {\n            this.enc = enc;\n            this.pos = pos;\n        }\n    }\n\n    get(pos) {\n        if (pos === undefined)\n            pos = this.pos++;\n        if (pos >= this.enc.length)\n            throw 'Requesting byte offset ' + pos + ' on a stream of length ' + this.enc.length;\n        return this.enc[pos];\n    };\n\n    hexByte(b) {\n        return Stream.hexDigits.charAt((b >> 4) & 0xF) + Stream.hexDigits.charAt(b & 0xF);\n    };\n\n    hexDump(start, end, raw) {\n        var s = \"\";\n        for (var i = start; i < end; ++i) {\n            s += this.hexByte(this.get(i));\n            if (raw !== true)\n                switch (i & 0xF) {\n                    case 0x7:\n                        s += \"  \";\n                        break;\n                    case 0xF:\n                        s += \"\\n\";\n                        break;\n                    default:\n                        s += \" \";\n                }\n        }\n        return s;\n    };\n\n    parseStringISO(start, end) {\n        var s = \"\";\n        for (var i = start; i < end; ++i)\n            s += String.fromCharCode(this.get(i));\n        return s;\n    };\n\n    parseStringUTF(start, end) {\n        var s = \"\";\n        for (var i = start; i < end;) {\n            var c = this.get(i++);\n            if (c < 128)\n                s += String.fromCharCode(c);\n            else if ((c > 191) && (c < 224))\n                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));\n            else\n                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));\n        }\n        return s;\n    };\n\n    parseStringBMP(start, end) {\n        var str = \"\"\n        for (var i = start; i < end; i += 2) {\n            var high_byte = this.get(i);\n            var low_byte = this.get(i + 1);\n            str += String.fromCharCode((high_byte << 8) + low_byte);\n        }\n\n        return str;\n    };\n\n    parseTime(start, end) {\n        var s = this.parseStringISO(start, end),\n            m = Stream.reTime.exec(s);\n        if (!m)\n            return \"Unrecognized time: \" + s;\n        s = m[1] + \"-\" + m[2] + \"-\" + m[3] + \" \" + m[4];\n        if (m[5]) {\n            s += \":\" + m[5];\n            if (m[6]) {\n                s += \":\" + m[6];\n                if (m[7])\n                    s += \".\" + m[7];\n            }\n        }\n        if (m[8]) {\n            s += \" UTC\";\n            if (m[8] != 'Z') {\n                s += m[8];\n                if (m[9])\n                    s += \":\" + m[9];\n            }\n        }\n        return s;\n    };\n\n    parseInteger(start, end) {\n        //TODO support negative numbers\n        var len = end - start;\n        if (len > 4) {\n            len <<= 3;\n            var s = this.get(start);\n            if (s === 0)\n                len -= 8;\n            else\n                while (s < 128) {\n                    s <<= 1;\n                    --len;\n                }\n            return \"(\" + len + \" bit)\";\n        }\n        var n = 0;\n        for (var i = start; i < end; ++i)\n            n = (n << 8) | this.get(i);\n        return n;\n    };\n\n    parseBitString(start, end) {\n        var unusedBit = this.get(start),\n            lenBit = ((end - start - 1) << 3) - unusedBit,\n            s = \"(\" + lenBit + \" bit)\";\n        if (lenBit <= 20) {\n            var skip = unusedBit;\n            s += \" \";\n            for (var i = end - 1; i > start; --i) {\n                var b = this.get(i);\n                for (var j = skip; j < 8; ++j)\n                    s += (b >> j) & 1 ? \"1\" : \"0\";\n                skip = 0;\n            }\n        }\n        return s;\n    };\n\n    parseOctetString(start, end) {\n        var len = end - start,\n            s = \"(\" + len + \" byte) \";\n        if (len > hardLimit)\n            end = start + hardLimit;\n        for (var i = start; i < end; ++i)\n            s += this.hexByte(this.get(i)); //TODO: also try Latin1?\n        if (len > hardLimit)\n            s += ellipsis;\n        return s;\n    };\n\n    parseOID(start, end) {\n        var s = '',\n            n = 0,\n            bits = 0;\n        for (var i = start; i < end; ++i) {\n            var v = this.get(i);\n            n = (n << 7) | (v & 0x7F);\n            bits += 7;\n            if (!(v & 0x80)) { // finished\n                if (s === '') {\n                    var m = n < 80 ? n < 40 ? 0 : 1 : 2;\n                    s = m + \".\" + (n - m * 40);\n                } else\n                    s += \".\" + ((bits >= 31) ? \"bigint\" : n);\n                n = bits = 0;\n            }\n        }\n        return s;\n    };\n}\n\nexport class ASN1 {\n    static get reSeemsASCII() {\n        return /^[ -~]+$/;\n    }\n\n    constructor(stream, header, length, tag, sub) {\n        this.stream = stream;\n        this.header = header;\n        this.length = length;\n        this.tag = tag;\n        this.sub = sub;\n    }\n\n    typeName() {\n        if (this.tag === undefined)\n            return \"unknown\";\n        var tagClass = this.tag >> 6,\n            tagConstructed = (this.tag >> 5) & 1,\n            tagNumber = this.tag & 0x1F;\n        switch (tagClass) {\n            case 0: // universal\n                switch (tagNumber) {\n                    case 0x00:\n                        return \"EOC\";\n                    case 0x01:\n                        return \"BOOLEAN\";\n                    case 0x02:\n                        return \"INTEGER\";\n                    case 0x03:\n                        return \"BIT_STRING\";\n                    case 0x04:\n                        return \"OCTET_STRING\";\n                    case 0x05:\n                        return \"NULL\";\n                    case 0x06:\n                        return \"OBJECT_IDENTIFIER\";\n                    case 0x07:\n                        return \"ObjectDescriptor\";\n                    case 0x08:\n                        return \"EXTERNAL\";\n                    case 0x09:\n                        return \"REAL\";\n                    case 0x0A:\n                        return \"ENUMERATED\";\n                    case 0x0B:\n                        return \"EMBEDDED_PDV\";\n                    case 0x0C:\n                        return \"UTF8String\";\n                    case 0x10:\n                        return \"SEQUENCE\";\n                    case 0x11:\n                        return \"SET\";\n                    case 0x12:\n                        return \"NumericString\";\n                    case 0x13:\n                        return \"PrintableString\"; // ASCII subset\n                    case 0x14:\n                        return \"TeletexString\"; // aka T61String\n                    case 0x15:\n                        return \"VideotexString\";\n                    case 0x16:\n                        return \"IA5String\"; // ASCII\n                    case 0x17:\n                        return \"UTCTime\";\n                    case 0x18:\n                        return \"GeneralizedTime\";\n                    case 0x19:\n                        return \"GraphicString\";\n                    case 0x1A:\n                        return \"VisibleString\"; // ASCII subset\n                    case 0x1B:\n                        return \"GeneralString\";\n                    case 0x1C:\n                        return \"UniversalString\";\n                    case 0x1E:\n                        return \"BMPString\";\n                    default:\n                        return \"Universal_\" + tagNumber.toString(16);\n                }\n            case 1:\n                return \"Application_\" + tagNumber.toString(16);\n            case 2:\n                return \"[\" + tagNumber + \"]\"; // Context\n            case 3:\n                return \"Private_\" + tagNumber.toString(16);\n        }\n    }\n\n    content() {\n        if (this.tag === undefined)\n            return null;\n        var tagClass = this.tag >> 6,\n            tagNumber = this.tag & 0x1F,\n            content = this.posContent(),\n            len = Math.abs(this.length);\n        if (tagClass !== 0) { // universal\n            if (this.sub !== null)\n                return \"(\" + this.sub.length + \" elem)\";\n            //TODO: TRY TO PARSE ASCII STRING\n            var s = this.stream.parseStringISO(content, content + Math.min(len, hardLimit));\n            if (ASN1.reSeemsASCII.test(s))\n                return s.substring(0, 2 * hardLimit) + ((s.length > 2 * hardLimit) ? ellipsis : \"\");\n            else\n                return this.stream.parseOctetString(content, content + len);\n        }\n        switch (tagNumber) {\n            case 0x01: // BOOLEAN\n                return (this.stream.get(content) === 0) ? \"false\" : \"true\";\n            case 0x02: // INTEGER\n                return this.stream.parseInteger(content, content + len);\n            case 0x03: // BIT_STRING\n                return this.sub ? \"(\" + this.sub.length + \" elem)\" :\n                    this.stream.parseBitString(content, content + len);\n            case 0x04: // OCTET_STRING\n                return this.sub ? \"(\" + this.sub.length + \" elem)\" :\n                    this.stream.parseOctetString(content, content + len);\n            //case 0x05: // NULL\n            case 0x06: // OBJECT_IDENTIFIER\n                return this.stream.parseOID(content, content + len);\n            //case 0x07: // ObjectDescriptor\n            //case 0x08: // EXTERNAL\n            //case 0x09: // REAL\n            //case 0x0A: // ENUMERATED\n            //case 0x0B: // EMBEDDED_PDV\n            case 0x10: // SEQUENCE\n            case 0x11: // SET\n                return \"(\" + this.sub.length + \" elem)\";\n            case 0x0C: // UTF8String\n                return this.stream.parseStringUTF(content, content + len);\n            case 0x12: // NumericString\n            case 0x13: // PrintableString\n            case 0x14: // TeletexString\n            case 0x15: // VideotexString\n            case 0x16: // IA5String\n            //case 0x19: // GraphicString\n            case 0x1A: // VisibleString\n                //case 0x1B: // GeneralString\n                //case 0x1C: // UniversalString\n                return this.stream.parseStringISO(content, content + len);\n            case 0x1E: // BMPString\n                return this.stream.parseStringBMP(content, content + len);\n            case 0x17: // UTCTime\n            case 0x18: // GeneralizedTime\n                return this.stream.parseTime(content, content + len);\n        }\n        return null;\n    };\n\n    toString() {\n        return this.typeName() + \"@\" + this.stream.pos + \"[header:\" + this.header + \",length:\" + this.length + \",sub:\" + ((this.sub === null) ? 'null' : this.sub.length) + \"]\";\n    };\n\n    print(indent) {\n        if (indent === undefined) indent = '';\n        document.writeln(indent + this);\n        if (this.sub !== null) {\n            indent += '  ';\n            for (var i = 0, max = this.sub.length; i < max; ++i)\n                this.sub[i].print(indent);\n        }\n    };\n\n    toPrettyString(indent) {\n        if (indent === undefined) indent = '';\n        var s = indent + this.typeName() + \" @\" + this.stream.pos;\n        if (this.length >= 0)\n            s += \"+\";\n        s += this.length;\n        if (this.tag & 0x20)\n            s += \" (constructed)\";\n        else if (((this.tag == 0x03) || (this.tag == 0x04)) && (this.sub !== null))\n            s += \" (encapsulates)\";\n        s += \"\\n\";\n        if (this.sub !== null) {\n            indent += '  ';\n            for (var i = 0, max = this.sub.length; i < max; ++i)\n                s += this.sub[i].toPrettyString(indent);\n        }\n        return s;\n    };\n\n    toDOM() {\n        var node = DOM.tag(\"div\", \"node\");\n        node.asn1 = this;\n        var head = DOM.tag(\"div\", \"head\");\n        var s = this.typeName().replace(/_/g, \" \");\n        head.innerHTML = s;\n        var content = this.content();\n        if (content !== null) {\n            content = String(content).replace(/</g, \"&lt;\");\n            var preview = DOM.tag(\"span\", \"preview\");\n            preview.appendChild(DOM.text(content));\n            head.appendChild(preview);\n        }\n        node.appendChild(head);\n        this.node = node;\n        this.head = head;\n        var value = DOM.tag(\"div\", \"value\");\n        s = \"Offset: \" + this.stream.pos + \"<br/>\";\n        s += \"Length: \" + this.header + \"+\";\n        if (this.length >= 0)\n            s += this.length;\n        else\n            s += (-this.length) + \" (undefined)\";\n        if (this.tag & 0x20)\n            s += \"<br/>(constructed)\";\n        else if (((this.tag == 0x03) || (this.tag == 0x04)) && (this.sub !== null))\n            s += \"<br/>(encapsulates)\";\n        //TODO if (this.tag == 0x03) s += \"Unused bits: \"\n        if (content !== null) {\n            s += \"<br/>Value:<br/><b>\" + content + \"</b>\";\n            if ((typeof oids === 'object') && (this.tag == 0x06)) {\n                var oid = oids[content];\n                if (oid) {\n                    if (oid.d) s += \"<br/>\" + oid.d;\n                    if (oid.c) s += \"<br/>\" + oid.c;\n                    if (oid.w) s += \"<br/>(warning!)\";\n                }\n            }\n        }\n        value.innerHTML = s;\n        node.appendChild(value);\n        var sub = DOM.tag(\"div\", \"sub\");\n        if (this.sub !== null) {\n            for (var i = 0, max = this.sub.length; i < max; ++i)\n                sub.appendChild(this.sub[i].toDOM());\n        }\n        node.appendChild(sub);\n        head.onclick = function () {\n            node.className = (node.className == \"node collapsed\") ? \"node\" : \"node collapsed\";\n        };\n        return node;\n    };\n\n    posStart() {\n        return this.stream.pos;\n    };\n\n    posContent() {\n        return this.stream.pos + this.header;\n    };\n\n    posEnd() {\n        return this.stream.pos + this.header + Math.abs(this.length);\n    };\n\n    fakeHover(current) {\n        this.node.className += \" hover\";\n        if (current)\n            this.head.className += \" hover\";\n    };\n\n    fakeOut(current) {\n        var re = / ?hover/;\n        this.node.className = this.node.className.replace(re, \"\");\n        if (current)\n            this.head.className = this.head.className.replace(re, \"\");\n    };\n\n    toHexDOM_sub(node, className, stream, start, end) {\n        if (start >= end)\n            return;\n        var sub = DOM.tag(\"span\", className);\n        sub.appendChild(DOM.text(\n            stream.hexDump(start, end)));\n        node.appendChild(sub);\n    };\n\n    toHexDOM(root) {\n        var node = DOM.tag(\"span\", \"hex\");\n        if (root === undefined) root = node;\n        this.head.hexNode = node;\n        this.head.onmouseover = function () {\n            this.hexNode.className = \"hexCurrent\";\n        };\n        this.head.onmouseout = function () {\n            this.hexNode.className = \"hex\";\n        };\n        node.asn1 = this;\n        node.onmouseover = function () {\n            var current = !root.selected;\n            if (current) {\n                root.selected = this.asn1;\n                this.className = \"hexCurrent\";\n            }\n            this.asn1.fakeHover(current);\n        };\n        node.onmouseout = function () {\n            var current = (root.selected == this.asn1);\n            this.asn1.fakeOut(current);\n            if (current) {\n                root.selected = null;\n                this.className = \"hex\";\n            }\n        };\n        this.toHexDOM_sub(node, \"tag\", this.stream, this.posStart(), this.posStart() + 1);\n        this.toHexDOM_sub(node, (this.length >= 0) ? \"dlen\" : \"ulen\", this.stream, this.posStart() + 1, this.posContent());\n        if (this.sub === null)\n            node.appendChild(DOM.text(\n                this.stream.hexDump(this.posContent(), this.posEnd())));\n        else if (this.sub.length > 0) {\n            var first = this.sub[0];\n            var last = this.sub[this.sub.length - 1];\n            this.toHexDOM_sub(node, \"intro\", this.stream, this.posContent(), first.posStart());\n            for (var i = 0, max = this.sub.length; i < max; ++i)\n                node.appendChild(this.sub[i].toHexDOM(root));\n            this.toHexDOM_sub(node, \"outro\", this.stream, last.posEnd(), this.posEnd());\n        }\n        return node;\n    };\n\n    toHexString(root) {\n        return this.stream.hexDump(this.posStart(), this.posEnd(), true);\n    };\n\n}\n\nASN1.decodeLength = function (stream) {\n    var buf = stream.get(),\n        len = buf & 0x7F;\n    if (len == buf)\n        return len;\n    if (len > 3)\n        throw \"Length over 24 bits not supported at position \" + (stream.pos - 1);\n    if (len === 0)\n        return -1; // undefined\n    buf = 0;\n    for (var i = 0; i < len; ++i)\n        buf = (buf << 8) | stream.get();\n    return buf;\n};\nASN1.hasContent = function (tag, len, stream) {\n    if (tag & 0x20) // constructed\n        return true;\n    if ((tag < 0x03) || (tag > 0x04))\n        return false;\n    var p = new Stream(stream);\n    if (tag == 0x03) p.get(); // BitString unused bits, must be in [0, 7]\n    var subTag = p.get();\n    if ((subTag >> 6) & 0x01) // not (universal or context)\n        return false;\n    try {\n        var subLength = ASN1.decodeLength(p);\n        return ((p.pos - stream.pos) + subLength == len);\n    } catch (exception) {\n        return false;\n    }\n};\nASN1.decode = function (stream) {\n    if (!(stream instanceof Stream))\n        stream = new Stream(stream, 0);\n    var streamStart = new Stream(stream),\n        tag = stream.get(),\n        len = ASN1.decodeLength(stream),\n        header = stream.pos - streamStart.pos,\n        sub = null;\n    if (ASN1.hasContent(tag, len, stream)) {\n        // it has content, so we decode it\n        var start = stream.pos;\n        if (tag == 0x03) stream.get(); // skip BitString unused bits, must be in [0, 7]\n        sub = [];\n        if (len >= 0) {\n            // definite length\n            var end = start + len;\n            while (stream.pos < end)\n                sub[sub.length] = ASN1.decode(stream);\n            if (stream.pos != end)\n                throw \"Content size is not correct for container starting at offset \" + start;\n        } else {\n            // undefined length\n            try {\n                for (; ;) {\n                    var s = ASN1.decode(stream);\n                    if (s.tag === 0)\n                        break;\n                    sub[sub.length] = s;\n                }\n                len = start - stream.pos;\n            } catch (e) {\n                throw \"Exception while decoding undefined length content: \" + e;\n            }\n        }\n    } else\n        stream.pos += len; // skip content\n    return new ASN1(streamStart, header, len, tag, sub);\n};\nASN1.test = function () {\n    var test = [\n        {value: [0x27], expected: 0x27},\n        {value: [0x81, 0xC9], expected: 0xC9},\n        {value: [0x83, 0xFE, 0xDC, 0xBA], expected: 0xFEDCBA}\n    ];\n    for (var i = 0, max = test.length; i < max; ++i) {\n        var pos = 0,\n            stream = new Stream(test[i].value, 0),\n            res = ASN1.decodeLength(stream);\n        if (res != test[i].expected)\n            document.write(\"In test[\" + i + \"] expected \" + test[i].expected + \" got \" + res + \"\\n\");\n    }\n};","// prng4.js - uses Arcfour as a PRNG\n\nexport class Arcfour {\n  constructor() {\n    this.i = 0;\n    this.j = 0;\n    this.S = [];\n  }\n}\n\n// Initialize arcfour context from key, an array of ints, each from [0..255]\nfunction ARC4init(key) {\n  var i, j, t;\n  for(i = 0; i < 256; ++i)\n    this.S[i] = i;\n  j = 0;\n  for(i = 0; i < 256; ++i) {\n    j = (j + this.S[i] + key[i % key.length]) & 255;\n    t = this.S[i];\n    this.S[i] = this.S[j];\n    this.S[j] = t;\n  }\n  this.i = 0;\n  this.j = 0;\n}\n\nfunction ARC4next() {\n  var t;\n  this.i = (this.i + 1) & 255;\n  this.j = (this.j + this.S[this.i]) & 255;\n  t = this.S[this.i];\n  this.S[this.i] = this.S[this.j];\n  this.S[this.j] = t;\n  return this.S[(t + this.S[this.i]) & 255];\n}\n\nArcfour.prototype.init = ARC4init;\nArcfour.prototype.next = ARC4next;\n\n// Plug in your RNG constructor here\nexport function prng_newstate() {\n  return new Arcfour();\n}\n\n// Pool size must be a multiple of 4 and greater than 32.\n// An array of bytes the size of the pool will be passed to init()\nexport var rng_psize = 256;\n","// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nexport class BigInteger {\n  constructor(a,b,c) {\n    if (a != null)\n      if (\"number\" == typeof a) this.fromNumber(a, b, c);\n      else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n      else this.fromString(a, b);\n  }\n}\n\n// return new, unset BigInteger\nexport function nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this[i++]+w[j]+c;\n    c = Math.floor(v/0x4000000);\n    w[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this[i]&0x7fff;\n    var h = this[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nif(j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != \"Netscape\")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = [];\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nexport function int2char(n) { return BI_RM.charAt(n); }\nexport function intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nexport function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nexport function nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nexport class Classic{\n  constructor(m){\n    this.m = m;\n  }\n}\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nexport class Montgomery {\n  constructor(m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n","// Base64 JavaScript decoder\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\n\nexport const Base64 = {};\nlet decoder;\n\nBase64.decode = function (a) {\n    var i;\n    if (decoder === undefined) {\n        var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n            ignore = \"= \\f\\n\\r\\t\\u00A0\\u2028\\u2029\";\n        decoder = [];\n        for (i = 0; i < 64; ++i)\n            decoder[b64.charAt(i)] = i;\n        for (i = 0; i < ignore.length; ++i)\n            decoder[ignore.charAt(i)] = -1;\n    }\n    var out = [];\n    var bits = 0, char_count = 0;\n    for (i = 0; i < a.length; ++i) {\n        var c = a.charAt(i);\n        if (c == '=')\n            break;\n        c = decoder[c];\n        if (c == -1)\n            continue;\n        if (c === undefined)\n            throw 'Illegal character at offset ' + i;\n        bits |= c;\n        if (++char_count >= 4) {\n            out[out.length] = (bits >> 16);\n            out[out.length] = (bits >> 8) & 0xFF;\n            out[out.length] = bits & 0xFF;\n            bits = 0;\n            char_count = 0;\n        } else {\n            bits <<= 6;\n        }\n    }\n    switch (char_count) {\n      case 1:\n        throw \"Base64 encoding incomplete: at least 2 bits missing\";\n      case 2:\n        out[out.length] = (bits >> 10);\n        break;\n      case 3:\n        out[out.length] = (bits >> 16);\n        out[out.length] = (bits >> 8) & 0xFF;\n        break;\n    }\n    return out;\n};\n\nBase64.re = /-----BEGIN [^-]+-----([A-Za-z0-9+\\/=\\s]+)-----END [^-]+-----|begin-base64[^\\n]+\\n([A-Za-z0-9+\\/=\\s]+)====/;\nBase64.unarmor = function (a) {\n    var m = Base64.re.exec(a);\n    if (m) {\n        if (m[1])\n            a = m[1];\n        else if (m[2])\n            a = m[2];\n        else\n            throw \"RegExp out of sync\";\n    }\n    return Base64.decode(a);\n};\n","// Hex JavaScript decoder\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\nexport const Hex = {};\nlet decoder;\n\nHex.decode = function(a) {\n    var i;\n    if (decoder === undefined) {\n        var hex = \"0123456789ABCDEF\",\n            ignore = \" \\f\\n\\r\\t\\u00A0\\u2028\\u2029\";\n        decoder = [];\n        for (i = 0; i < 16; ++i)\n            decoder[hex.charAt(i)] = i;\n        hex = hex.toLowerCase();\n        for (i = 10; i < 16; ++i)\n            decoder[hex.charAt(i)] = i;\n        for (i = 0; i < ignore.length; ++i)\n            decoder[ignore.charAt(i)] = -1;\n    }\n    var out = [],\n        bits = 0,\n        char_count = 0;\n    for (i = 0; i < a.length; ++i) {\n        var c = a.charAt(i);\n        if (c == '=')\n            break;\n        c = decoder[c];\n        if (c == -1)\n            continue;\n        if (c === undefined)\n            throw 'Illegal character at offset ' + i;\n        bits |= c;\n        if (++char_count >= 2) {\n            out[out.length] = bits;\n            bits = 0;\n            char_count = 0;\n        } else {\n            bits <<= 4;\n        }\n    }\n    if (char_count)\n        throw \"Hex encoding incomplete: 4 bits missing\";\n    return out;\n};","function SMediaError(data) {\r\n    if(data instanceof SMediaError) {\r\n        return data;\r\n    }\r\n\r\n    if (typeof data === 'number') {\r\n        this.code = data;\r\n    } else if (typeof value === 'string') {\r\n        this.message = data;\r\n    }\r\n\r\n    if (!this.message) {\r\n        this.message = SMediaError.defaultMessages[this.code] || '';\r\n    }\r\n}\r\n\r\nSMediaError.prototype.code = 0;\r\nSMediaError.prototype.message = '';\r\n\r\nSMediaError.errorTypes = [\r\n    'MEDIA_ERR_CUSTOM',\r\n    'MEDIA_ERR_ABORTED',\r\n    'MEDIA_ERR_NETWORK',\r\n    'MEDIA_ERR_DECODE',\r\n    'MEDIA_ERR_SRC_NOT_SUPPORTED',\r\n    'MEDIA_ERR_ENCRYPTED',\r\n    'MEDIA_ERR_TRANSPORT'\r\n];\r\n\r\nSMediaError.defaultMessages = {\r\n    1: 'The fetching of the associated resource was aborted by the user\\'s request.',\r\n    2: 'Some kind of network error occurred which prevented the media from being successfully fetched, despite having previously been available.',\r\n    3: 'Despite having previously been determined to be usable, an error occurred while trying to decode the media resource, resulting in an error.',\r\n    4: 'The associated resource or media provider object (such as a MediaStream) has been found to be unsuitable.',\r\n    5: 'The media is encrypted and we do not have the keys to decrypt it.',\r\n    6: 'Transport error'\r\n};\r\n\r\nfor (let errIndex = 0; errIndex < SMediaError.errorTypes.length; errIndex++) {\r\n    SMediaError[SMediaError.errorTypes[errIndex]] = errIndex;\r\n    SMediaError.prototype[SMediaError.errorTypes[errIndex]] = errIndex;\r\n}\r\nexport default SMediaError;","import {getTagged} from './deps/bp_logger.js';\r\nimport {Url} from './core/util/url.js';\r\nimport {Remuxer} from './core/remuxer/remuxer.js';\r\nimport DEFAULT_CLIENT from './client/rtsp/client.js';\r\nimport DEFAULT_TRANSPORT from './transport/websocket.js';\r\nimport SMediaError from './media_error';\r\nimport { MediaRecorder } from './recorder.js';\r\n\r\nconst Log = getTagged('wsp');\r\n\r\nexport class StreamType {\r\n    static get HLS() {return 'hls';}\r\n    static get RTSP() {return 'rtsp';}\r\n\r\n    static isSupported(type) {\r\n        return [StreamType.HLS, StreamType.RTSP].includes(type);\r\n    }\r\n\r\n    static fromUrl(url) {\r\n        let parsed;\r\n        try {\r\n            parsed = Url.parse(url);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n        switch (parsed.protocol) {\r\n            case 'rtsp':\r\n                return StreamType.RTSP;\r\n            case 'http':\r\n            case 'https':\r\n                if (url.indexOf('.m3u8')>=0) {\r\n                    return StreamType.HLS;\r\n                } else {\r\n                    return null;\r\n                }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    static fromMime(mime) {\r\n        switch (mime) {\r\n            case 'application/x-rtsp':\r\n                return StreamType.RTSP;\r\n            case 'application/vnd.apple.mpegurl':\r\n            case 'application/x-mpegurl':\r\n                return StreamType.HLS;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\nexport class WSPlayer {\r\n\r\n    constructor(node, opts) {\r\n        if (typeof node == typeof '') {\r\n            this.player = document.getElementById(node);\r\n        } else {\r\n            this.player = node;\r\n        }\r\n\r\n        let modules = opts.modules || {\r\n            client: DEFAULT_CLIENT,\r\n            transport: {\r\n                constructor: DEFAULT_TRANSPORT\r\n            }\r\n        };\r\n        this.errorHandler = opts.errorHandler || null;\r\n        this.infoHandler = opts.infoHandler || null;\r\n        this.dataHandler = opts.dataHandler || null;\r\n        this.queryCredentials = opts.queryCredentials || null;\r\n\r\n        this.bufferDuration_ = opts.bufferDuration || 120;\r\n        if(isNaN(this.bufferDuration_) || (this.bufferDuration_ <= 0)){\r\n            Log.warn(\"Expected number type for bufferDuration\");\r\n            this.bufferDuration_ = 120;\r\n        }\r\n\r\n        this.continuousRecording = new MediaRecorder(this, 'continuous');\r\n        this.eventRecording = new MediaRecorder(this, 'event');\r\n        this.continuousRecording.setFileLength(opts.continuousFileLength);\r\n        this.eventRecording.setFileLength(opts.eventFileLength);\r\n\r\n        this.modules = {};\r\n        for (let module of modules) {\r\n            let transport = module.transport || DEFAULT_TRANSPORT;\r\n            let client = module.client || DEFAULT_CLIENT;\r\n            if (transport.constructor.canTransfer(client.streamType())) {\r\n                this.modules[client.streamType()] = {\r\n                    client: client,\r\n                    transport: transport\r\n                }\r\n            } else {\r\n                Log.warn(`Client stream type ${client.streamType()} is incompatible with transport types [${transport.streamTypes().join(', ')}]. Skip`)\r\n            }\r\n        }\r\n        \r\n        this.type = StreamType.RTSP;\r\n        this.url = null;\r\n        if (opts.url && opts.type) {\r\n            this.url = opts.url;\r\n            this.type = opts.type;\r\n        } else {\r\n            if (!this._checkSource(this.player)) {\r\n                for (let i=0; i<this.player.children.length; ++i) {\r\n                    if (this._checkSource(this.player.children[i])) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // if (!this.url) {\r\n            //      throw new Error('No playable endpoint found');\r\n            // }\r\n        }\r\n\r\n        if (this.url) {\r\n            this.setSource(this.url, this.type);\r\n        }\r\n\r\n        this.player.addEventListener('play', ()=>{\r\n            this.continuousRecording.pause(false);\r\n            this.eventRecording.pause(false);\r\n\r\n            if (!this.isPlaying()) {\r\n                this.client.start();\r\n            }\r\n        }, false);\r\n\r\n        this.player.addEventListener('pause', ()=>{\r\n            this.client.stop();\r\n            this.continuousRecording.pause(true);\r\n            this.eventRecording.pause(true);\r\n        }, false);\r\n\r\n        this.player.addEventListener('seeking', ()=>{\r\n            if(this.player.buffered.length) {\r\n                let bStart = this.player.buffered.start(0);\r\n                let bEnd   = this.player.buffered.end(0);\r\n                let bDuration = bEnd - bStart;\r\n\r\n                if (bDuration > 0 && (this.player.currentTime < bStart || this.player.currentTime > bEnd)) {\r\n                    if(this.player.currentTime < bStart){\r\n                        this.player.currentTime = bStart;\r\n                    }\r\n                    else{\r\n                        this.player.currentTime = bEnd - 1;\r\n                    }\r\n                }\r\n            }\r\n        }, false);\r\n\r\n        this.player.addEventListener('abort', () => {\r\n            // disconnect the transport when the player is closed\r\n            this.client.stop();\r\n            this.transport.disconnect().then(() => {\r\n                this.client.destroy();\r\n            });\r\n        }, false);\t\t\r\n\r\n        this.redirectNativeMediaErrors = opts.hasOwnProperty('redirectNativeMediaErrors') ?\r\n            opts.redirectNativeMediaErrors : true;\r\n\r\n        if(this.redirectNativeMediaErrors) {\r\n            this.player.addEventListener('error', () => {\r\n                this.error(this.player.error.code);\r\n            }, false);\r\n        }\r\n    }\r\n\r\n    // TODO: check native support\r\n\r\n    isPlaying() {\r\n        return !(this.player.paused || this.client.paused);\r\n    }\r\n\r\n    static canPlayWithModules(mimeType, modules) {\r\n\r\n        let filteredModules = {};\r\n        for (let module of modules) {\r\n            let transport = module.transport || DEFAULT_TRANSPORT;\r\n            let client = module.client || DEFAULT_CLIENT;\r\n            if (transport.canTransfer(client.streamType())) {\r\n                filteredModules[client.streamType()] = true;\r\n            }\r\n        }\r\n\r\n        for (let type in filteredModules) {\r\n            if (type == StreamType.fromMime(mimeType)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// TODO: deprecate it?\r\n    static canPlay(resource) {\r\n        return StreamType.fromMime(resource.type) || StreamType.fromUrl(resource.src);\r\n    }\r\n\r\n    canPlayUrl(src) {\r\n        let type = StreamType.fromUrl(src);\r\n        return (type in this.modules);\r\n    }\r\n\r\n    _checkSource(src) {\r\n        if (!src.dataset['ignore'] && src.src && !this.player.canPlayType(src.type) && (StreamType.fromMime(src.type) || StreamType.fromUrl(src.src))) {\r\n            this.url = src.src;\r\n            this.type = src.type ? StreamType.fromMime(src.type) : StreamType.fromUrl(src.src);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    async setSource(url, type) {\r\n        if (this.transport) {\r\n            if (this.client) {\r\n                await this.client.detachTransport();\r\n            }\r\n            await this.transport.destroy();\r\n        }\r\n        try {\r\n            this.endpoint = Url.parse(url);\r\n        } catch (e) {\r\n            this.error(SMediaError.MEDIA_ERR_SRC_NOT_SUPPORTED);\r\n            return;\r\n        }\r\n\r\n        this.url = url;\r\n        let transport = this.modules[type].transport;\r\n        this.transport = new transport.constructor(this.endpoint, this.type, transport.options);\r\n        this.transport.eventSource.addEventListener('error', (errorEvent)=>{\r\n            this.error(errorEvent.detail);\r\n        });\r\n        this.transport.eventSource.addEventListener('info', (infoEvent)=>{\r\n            this.info(infoEvent.detail)\r\n        });\r\n\r\n        let lastType = this.type;\r\n        this.type = (StreamType.isSupported(type)?type:false) || StreamType.fromMime(type);\r\n        if (!this.type) {\r\n            this.error(SMediaError.MEDIA_ERR_SRC_NOT_SUPPORTED);\r\n            return;\r\n        }\r\n\r\n        if (lastType!=this.type || !this.client) {\r\n            if (this.client) {\r\n                await this.client.destroy();\r\n            }\r\n            let client = this.modules[type].client;\r\n            let opts = {errorHandler: this.errorHandler, flush: 200};\r\n            this.client = new client(opts);\r\n        } else {\r\n            this.client.reset();\r\n        }\r\n\r\n        if (this.queryCredentials) {\r\n            this.client.queryCredentials = this.queryCredentials;\r\n        }\r\n        if (this.remuxer) {\r\n            this.continuousRecording.dettachSource();\r\n            this.eventRecording.dettachSource();\r\n            this.remuxer.destroy();\r\n            this.remuxer = null;\r\n        }\r\n        this.remuxer = new Remuxer(this.player);\r\n        this.remuxer.MSE.bufferDuration = this.bufferDuration_;\r\n        this.remuxer.attachClient(this.client);\r\n\r\n        this.continuousRecording.attachSource(this.remuxer);\r\n        this.eventRecording.attachSource(this.remuxer);\r\n\r\n        this.client.attachTransport(this.transport);\r\n        this.client.setSource(this.endpoint);\r\n\r\n        if (this.player.autoplay) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    set bufferDuration(duration){\r\n        if(this.remuxer && this.remuxer.MSE) {\r\n            this.bufferDuration_ = duration;\r\n            this.remuxer.MSE.bufferDuration = duration;\r\n        }\r\n    }\r\n\r\n    get bufferDuration(){\r\n        if(this.remuxer)\r\n            return this.remuxer.MSE.bufferDuration;\r\n        else\r\n            return undefined;\r\n    }\r\n\r\n    error(err){\r\n        if (err !== undefined) {\r\n            this.error_ = new SMediaError(err);\r\n            if (this.errorHandler){\r\n                Log.error(this.error_.message);\r\n                this.errorHandler(this.error_);\r\n            }\r\n        }\r\n        return this.error_;\r\n    }\r\n\r\n    info(inf){\r\n        if (inf !== undefined) {\r\n            if (this.infoHandler){\r\n                this.infoHandler(inf);\r\n            }\r\n        }\r\n    }\r\n\r\n    mediadata(data, prefix){\r\n        if (data !== undefined) {\r\n            if (this.dataHandler){\r\n                this.dataHandler(data, prefix);\r\n            }\r\n        }\r\n    }\r\n\r\n    start() {\r\n        if (this.client) {\r\n            this.client.start().catch((e)=>{\r\n                if (this.errorHandler) {\r\n                    this.errorHandler(e);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.client) {\r\n            this.client.stop();\r\n        }\r\n    }\r\n\r\n    async destroy() {\r\n        if (this.transport) {\r\n            if (this.client) {\r\n                await this.client.detachTransport();\r\n            }\r\n            await this.transport.destroy();\r\n        }\r\n        if (this.client) {\r\n            await this.client.destroy();\r\n        }\r\n        if (this.remuxer) {\r\n            this.remuxer.destroy();\r\n            this.remuxer = null;\r\n        }\r\n\r\n        this.continuousRecording.destroy();\r\n        this.eventRecording.destroy();\r\n    }\r\n\r\n}\r\n","import {getTagged} from '../../deps/bp_logger.js';\r\nimport {StateMachine} from '../../deps/bp_statemachine.js';\r\nimport {SDPParser} from '../../core/parsers/sdp.js';\r\nimport {RTSPStream} from './stream.js';\r\nimport md5 from '../../core/util/md5';\r\n// import {RTP} from './rtp/rtp';\r\nimport RTPFactory from './rtp/factory.js';\r\nimport {MessageBuilder} from './message.js';\r\nimport {RTPPayloadParser} from './rtp/payload/parser.js';\r\nimport {BaseClient} from '../../core/base_client.js';\r\nimport {PayloadType} from '../../core/defs.js';\r\nimport {base64ToArrayBuffer, hexToByteArray} from '../../core/util/binary.js';\r\nimport {AACParser} from '../../core/parsers/aac.js';\r\nimport {RTSPSession} from \"./session\";\r\n\r\nconst LOG_TAG = \"client:rtsp\";\r\nconst Log = getTagged(LOG_TAG);\r\n\r\nexport class RTPError {\r\n    constructor(message, file, line) {\r\n        //super(message, file, line);\r\n    }\r\n}\r\n\r\nexport default class RTSPClient extends BaseClient {\r\n    constructor(options={flush: 200}) {\r\n        super(options);\r\n        this.clientSM = new RTSPClientSM(this);\r\n        this.clientSM.ontracks = (tracks) => {\r\n            this.eventSource.dispatchEvent('tracks', tracks);\r\n            this.startStreamFlush();\r\n        };\r\n        this.sampleQueues={};\r\n    }\r\n    \r\n    static streamType() {\r\n        return 'rtsp';\r\n    }\r\n\r\n    setSource(url) {\r\n        super.setSource(url);\r\n        this.clientSM.setSource(url);\r\n    }\r\n    attachTransport(transport) {\r\n        super.attachTransport(transport);\r\n        this.clientSM.transport = transport;\r\n    }\r\n\r\n    detachTransport() {\r\n        super.detachTransport();\r\n        this.clientSM.transport = null;\r\n    }\r\n\r\n    reset() {\r\n        super.reset();\r\n        this.sampleQueues={};\r\n    }\r\n\r\n    destroy() {\r\n        this.clientSM.destroy();\r\n        return super.destroy();\r\n    }\r\n\r\n    start() {\r\n        super.start();\r\n        if (this.transport) {\r\n            return this.transport.ready.then(() => {\r\n                return this.clientSM.start();\r\n            });\r\n        } else {\r\n            return Promise.reject(\"no transport attached\");\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        super.stop();\r\n        return this.clientSM.stop();\r\n    }\r\n\r\n    onData(data) {\r\n        this.clientSM.onData(data);\r\n    }\r\n\r\n    onConnected() {\r\n        this.clientSM.onConnected();\r\n        super.onConnected();\r\n    }\r\n\r\n    onDisconnected() {\r\n        super.onDisconnected();\r\n        this.clientSM.onDisconnected();\r\n    }\r\n}\r\n\r\nclass AuthError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n    }\r\n}\r\n\r\nexport class RTSPError extends Error {\r\n    constructor(data) {\r\n        super(data.msg);\r\n        this.data = data;\r\n    }\r\n}\r\n\r\nexport class RTSPClientSM extends StateMachine {\r\n    static get USER_AGENT() {return 'SFRtsp 0.3';}\r\n    static get STATE_INITIAL() {return  1 << 0;}\r\n    static get STATE_OPTIONS() {return 1 << 1;}\r\n    static get STATE_DESCRIBE () {return  1 << 2;}\r\n    static get STATE_SETUP() {return  1 << 3;}\r\n    static get STATE_STREAMS() {return 1 << 4;}\r\n    static get STATE_TEARDOWN() {return  1 << 5;}\r\n    static get STATE_PLAY() {return  1 << 6;}\r\n    static get STATE_PLAYING() {return  1 << 7;}\r\n    static get STATE_PAUSE() {return  1 << 8;}\r\n    static get STATE_PAUSED() {return  1 << 9;}\r\n    // static STATE_PAUSED = 1 << 6;\r\n\r\n    constructor(parent) {\r\n        super();\r\n\r\n        this.parent = parent;\r\n        this.transport = null;\r\n        this.payParser = new RTPPayloadParser();\r\n        this.rtp_channels = new Set();\r\n        this.sessions = {};\r\n        this.ontracks = null;\r\n\r\n        this.addState(RTSPClientSM.STATE_INITIAL,{\r\n        }).addState(RTSPClientSM.STATE_OPTIONS, {\r\n            activate: this.sendOptions,\r\n            finishTransition: this.onOptions\r\n        }).addState(RTSPClientSM.STATE_DESCRIBE, {\r\n            activate: this.sendDescribe,\r\n            finishTransition: this.onDescribe\r\n        }).addState(RTSPClientSM.STATE_SETUP, {\r\n            activate: this.sendSetup,\r\n            finishTransition: this.onSetup\r\n        }).addState(RTSPClientSM.STATE_STREAMS, {\r\n\r\n        }).addState(RTSPClientSM.STATE_TEARDOWN, {\r\n            activate: ()=>{\r\n                this.started = false;\r\n            },\r\n            finishTransition: ()=>{\r\n                return this.transitionTo(RTSPClientSM.STATE_INITIAL)\r\n            }\r\n        }).addTransition(RTSPClientSM.STATE_INITIAL, RTSPClientSM.STATE_OPTIONS)\r\n            .addTransition(RTSPClientSM.STATE_INITIAL, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_OPTIONS, RTSPClientSM.STATE_DESCRIBE)\r\n            .addTransition(RTSPClientSM.STATE_DESCRIBE, RTSPClientSM.STATE_SETUP)\r\n            .addTransition(RTSPClientSM.STATE_SETUP, RTSPClientSM.STATE_STREAMS)\r\n            .addTransition(RTSPClientSM.STATE_TEARDOWN, RTSPClientSM.STATE_INITIAL)\r\n            // .addTransition(RTSPClientSM.STATE_STREAMS, RTSPClientSM.STATE_PAUSED)\r\n            // .addTransition(RTSPClientSM.STATE_PAUSED, RTSPClientSM.STATE_STREAMS)\r\n            .addTransition(RTSPClientSM.STATE_STREAMS, RTSPClientSM.STATE_TEARDOWN)\r\n            // .addTransition(RTSPClientSM.STATE_PAUSED, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_SETUP, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_DESCRIBE, RTSPClientSM.STATE_TEARDOWN)\r\n            .addTransition(RTSPClientSM.STATE_OPTIONS, RTSPClientSM.STATE_TEARDOWN);\r\n\r\n        this.reset();\r\n\r\n        this.shouldReconnect = false;\r\n\r\n        // TODO: remove listeners\r\n        // this.connection.eventSource.addEventListener('connected', ()=>{\r\n        //     if (this.shouldReconnect) {\r\n        //         this.reconnect();\r\n        //     }\r\n        // });\r\n        // this.connection.eventSource.addEventListener('disconnected', ()=>{\r\n        //     if (this.started) {\r\n        //         this.shouldReconnect = true;\r\n        //     }\r\n        // });\r\n        // this.connection.eventSource.addEventListener('data', (data)=>{\r\n        //     let channel = new DataView(data).getUint8(1);\r\n        //     if (this.rtp_channels.has(channel)) {\r\n        //         this.onRTP({packet: new Uint8Array(data, 4), type: channel});\r\n        //     }\r\n        //\r\n        // });\r\n    }\r\n\r\n    destroy() {\r\n        this.parent = null;\r\n    }\r\n\r\n    setSource(url) {\r\n        this.reset();\r\n        this.endpoint = url;\r\n        this.url = `${url.protocol}://${url.location}${url.urlpath}`;\r\n    }\r\n\r\n    onConnected() {\r\n        if (this.rtpFactory) {\r\n            this.rtpFactory = null;\r\n        }\r\n        if (this.shouldReconnect) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    async onDisconnected() {\r\n        this.reset();\r\n        this.shouldReconnect = true;\r\n        await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n        await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n    }\r\n\r\n    start() {\r\n        if (this.currentState.name !== RTSPClientSM.STATE_STREAMS) {\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        } else {\r\n            // TODO: seekable\r\n            let promises = [];\r\n            for (let session in this.sessions) {\r\n                promises.push(this.sessions[session].sendPlay());\r\n            }\r\n            return Promise.all(promises);\r\n        }\r\n    }\r\n\r\n    onData(data) {\r\n        let channel = data[1];\r\n        if (this.rtp_channels.has(channel)) {\r\n            this.onRTP({packet: data.subarray(4), type: channel});\r\n        }\r\n    }\r\n\r\n    useRTPChannel(channel) {\r\n        this.rtp_channels.add(channel);\r\n    }\r\n\r\n    forgetRTPChannel(channel) {\r\n        this.rtp_channels.delete(channel);\r\n    }\r\n\r\n    stop() {\r\n        this.shouldReconnect = false;\r\n        let promises = [];\r\n        for (let session in this.sessions) {\r\n            promises.push(this.sessions[session].sendPause());\r\n        }\r\n        return Promise.all(promises);\r\n        // this.mse = null;\r\n    }\r\n\r\n    async reset() {\r\n        this.authenticator = '';\r\n        this.methods = [];\r\n        this.tracks = [];\r\n        this.rtpBuffer={};\r\n        for (let stream in this.streams) {\r\n            this.streams[stream].reset();\r\n        }\r\n        for (let session in this.sessions) {\r\n            this.sessions[session].reset();\r\n        }\r\n        this.streams={};\r\n        this.sessions={};\r\n        this.contentBase = \"\";\r\n        if (this.currentState) {\r\n            if (this.currentState.name != RTSPClientSM.STATE_INITIAL) {\r\n                await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n                await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n            }\r\n        } else {\r\n            await this.transitionTo(RTSPClientSM.STATE_INITIAL);\r\n        }\r\n        this.sdp = null;\r\n        this.interleaveChannelIndex = 0;\r\n        this.session = null;\r\n        this.timeOffset = {};\r\n        this.lastTimestamp = {};\r\n    }\r\n\r\n    async reconnect() {\r\n        //this.parent.eventSource.dispatchEvent('clear');\r\n        await this.reset();\r\n        if (this.currentState.name != RTSPClientSM.STATE_INITIAL) {\r\n            await this.transitionTo(RTSPClientSM.STATE_TEARDOWN);\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        } else {\r\n            return this.transitionTo(RTSPClientSM.STATE_OPTIONS);\r\n        }\r\n    }\r\n\r\n    supports(method) {\r\n        return this.methods.includes(method)\r\n    }\r\n\r\n    parse(_data) {\r\n        Log.debug(_data.payload);\r\n        let d=_data.payload.split('\\r\\n\\r\\n');\r\n        let parsed =  MessageBuilder.parse(d[0]);\r\n        let len = Number(parsed.headers['content-length']);\r\n        if (len) {\r\n            let d=_data.payload.split('\\r\\n\\r\\n');\r\n            parsed.body = d[1];\r\n        } else {\r\n            parsed.body=\"\";\r\n        }\r\n        return parsed\r\n    }\r\n\r\n    sendRequest(_cmd, _host, _params={}, _payload=null) {\r\n        this.cSeq++;\r\n        Object.assign(_params, {\r\n            CSeq: this.cSeq,\r\n            'User-Agent': RTSPClientSM.USER_AGENT\r\n        });\r\n        if (this.authenticator) {\r\n            _params['Authorization'] = this.authenticator(_cmd);\r\n        }\r\n        return this.send(MessageBuilder.build(_cmd, _host, _params, _payload), _cmd).catch((e)=>{\r\n            if ((e instanceof AuthError) && !_params['Authorization'] ) {\r\n                return this.sendRequest(_cmd, _host, _params, _payload);\r\n            } else {\r\n                throw e;\r\n            }\r\n        });\r\n    }\r\n\r\n    async send(_data, _method) {\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.ready;\r\n            } catch(e) {\r\n                this.onDisconnected();\r\n                throw e;\r\n            }\r\n            Log.debug(_data);\r\n            let response = await this.transport.send(_data);\r\n            let parsed = this.parse(response);\r\n            // TODO: parse status codes\r\n            if (parsed.code == 401 /*&& !this.authenticator */) {\r\n                Log.debug(parsed.headers['www-authenticate']);\r\n                let auth = parsed.headers['www-authenticate'];\r\n                let method = auth.substring(0, auth.indexOf(' '));\r\n                auth = auth.substr(method.length+1);\r\n                let chunks = auth.split(',');\r\n\r\n                let ep = this.parent.endpoint;\r\n                if (!ep.user || !ep.pass) {\r\n                    try {\r\n                        await this.parent.queryCredentials.call(this.parent);\r\n                    } catch (e) {\r\n                        throw new AuthError();\r\n                    }\r\n                }\r\n\r\n                if (method.toLowerCase() == 'digest') {\r\n                    let parsedChunks = {};\r\n                    for (let chunk of chunks) {\r\n                        let c = chunk.trim();\r\n                        let [k,v] = c.split('=');\r\n                        parsedChunks[k] = v.substr(1, v.length-2);\r\n                    }\r\n                    this.authenticator = (_method)=>{\r\n                        let ep = this.parent.endpoint;\r\n                        let ha1 = md5(`${ep.user}:${parsedChunks.realm}:${ep.pass}`);\r\n                        let ha2 = md5(`${_method}:${this.url}`);\r\n                        let response = md5(`${ha1}:${parsedChunks.nonce}:${ha2}`);\r\n                        let tail=''; // TODO: handle other params\r\n                        return `Digest username=\"${ep.user}\", realm=\"${parsedChunks.realm}\", nonce=\"${parsedChunks.nonce}\", uri=\"${this.url}\", response=\"${response}\"${tail}`;\r\n                    }\r\n                } else {\r\n                    this.authenticator = ()=>{return `Basic ${btoa(this.parent.endpoint.auth)}`;};\r\n                }\r\n\r\n                throw new AuthError(parsed);\r\n            }\r\n            if (parsed.code >= 300) {\r\n                Log.error(parsed.statusLine);\r\n                this.parent.options.errorHandler(new RTSPError({msg: `RTSP error: ${parsed.code} ${parsed.statusLine}`, parsed: parsed}));\r\n            }\r\n            return parsed;\r\n        } else {\r\n            return Promise.reject(\"No transport attached\");\r\n        }\r\n    }\r\n\r\n    sendOptions() {\r\n        this.reset();\r\n        this.started = true;\r\n        this.cSeq = 0;\r\n        return this.sendRequest('OPTIONS', this.url, {});\r\n    }\r\n\r\n    onOptions(data) {\r\n        this.methods = data.headers['public'].split(',').map((e)=>e.trim());\r\n        this.transitionTo(RTSPClientSM.STATE_DESCRIBE);\r\n    }\r\n\r\n    sendDescribe() {\r\n        return this.sendRequest('DESCRIBE', this.url, {\r\n            'Accept': 'application/sdp'\r\n        }).then((data)=>{\r\n            this.sdp = new SDPParser();\r\n            return this.sdp.parse(data.body).catch(()=>{\r\n                throw new Error(\"Failed to parse SDP\");\r\n            }).then(()=>{return data;});\r\n        });\r\n    }\r\n\r\n    onDescribe(data) {\r\n        this.contentBase = data.headers['content-base'] || this.url;// `${this.endpoint.protocol}://${this.endpoint.location}${this.endpoint.urlpath}/`;\r\n        this.tracks = this.sdp.getMediaBlockList();\r\n        this.rtpFactory = new RTPFactory(this.sdp);\r\n\r\n        Log.log('SDP contained ' + this.tracks.length + ' track(s). Calling SETUP for each.');\r\n\r\n        if (data.headers['session']) {\r\n            this.session = data.headers['session'];\r\n        }\r\n\r\n        if (!this.tracks.length) {\r\n            throw new Error(\"No tracks in SDP\");\r\n        }\r\n\r\n        this.transitionTo(RTSPClientSM.STATE_SETUP);\r\n    }\r\n\r\n    sendSetup() {\r\n        let streams=[];\r\n\t\tlet lastPromise = null;\r\n\r\n        // TODO: select first video and first audio tracks\r\n        for (let track_type of this.tracks) {\r\n            Log.log(\"setup track: \"+track_type);\r\n            // if (track_type=='audio') continue;\r\n            // if (track_type=='video') continue;\r\n            let track = this.sdp.getMediaBlock(track_type);\r\n            // If payload type is defined in the specification then \"rtpmap\" may be not specified\r\n            if (!track.rtpmap[track.fmt[0]]) {\r\n                Log.warn(`Pyload type \"${track.fmt[0]}\" is not supported`);\r\n                continue;\r\n            }\r\n\r\n            // If payload type is dynamic then check it encoding name\r\n            if (!PayloadType.string_map[track.rtpmap[track.fmt[0]].name]) {\r\n                Log.warn(`Pyload type \"${track.rtpmap[track.fmt[0]].name}\" is not supported`);\r\n                continue;\r\n            }\r\n\r\n            this.streams[track_type] = new RTSPStream(this, track);\r\n            let setupPromise = this.streams[track_type].start(lastPromise);\r\n            lastPromise = setupPromise;\r\n            this.parent.sampleQueues[PayloadType.string_map[track.rtpmap[track.fmt[0]].name]]=[];\r\n            this.rtpBuffer[track.fmt[0]]=[];\r\n            streams.push(setupPromise.then(({track, data})=>{\r\n                let timeOffset = 0;\r\n                this.timeOffset[track.fmt[0]] = 0;\r\n                try {\r\n                    let rtp_info = data.headers[\"rtp-info\"].split(';');\r\n                    for (let chunk of rtp_info) {\r\n                        let [key, val] = chunk.split(\"=\");\r\n                        if (key === \"rtptime\") {\r\n                            this.timeOffset[track.fmt[0]] = 0;//Number(val);\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // new Date().getTime();\r\n                }\r\n                let params = {\r\n                    timescale: 0,\r\n                    scaleFactor: 0\r\n                };\r\n                if (track.fmtp) {\r\n                    if (track.fmtp['sprop-parameter-sets']) {\r\n                        let sps_pps = track.fmtp['sprop-parameter-sets'].split(',');\r\n                        params = {\r\n                            sps:base64ToArrayBuffer(sps_pps[0]),\r\n                            pps:base64ToArrayBuffer(sps_pps[1])\r\n                        };\r\n                    } else if (track.fmtp['config']) {\r\n                        let config = track.fmtp['config'];\r\n                        this.has_config = track.fmtp['cpresent']!='0';\r\n                        let generic = track.rtpmap[track.fmt[0]].name == 'MPEG4-GENERIC';\r\n                        if (generic) {\r\n                            params={config:\r\n                                AACParser.parseAudioSpecificConfig(hexToByteArray(config))\r\n                            };\r\n                            this.payParser.aacparser.setConfig(params.config);\r\n                        } else if (config) {\r\n                            // todo: parse audio specific config for mpeg4-generic\r\n                            params={config:\r\n                                AACParser.parseStreamMuxConfig(hexToByteArray(config))\r\n                            };\r\n                            this.payParser.aacparser.setConfig(params.config);\r\n                        }\r\n                    }\r\n                }\r\n                params.duration = this.sdp.sessionBlock.range?this.sdp.sessionBlock.range[1]-this.sdp.sessionBlock.range[0]:1;\r\n                this.parent.seekable = (params.duration > 1);\r\n                let res = {\r\n                    track: track,\r\n                    offset: this.timeOffset[track.fmt[0]],\r\n                    type: PayloadType.string_map[track.rtpmap[track.fmt[0]].name],\r\n                    params: params,\r\n                    duration: params.duration\r\n                };\r\n                console.log(res, this.timeOffset);\r\n                let session = data.headers.session.split(';')[0];\r\n                if (!this.sessions[session]) {\r\n                    this.sessions[session] = new RTSPSession(this, session);\r\n                }\r\n                return res;\r\n            }));\r\n        }\r\n        return Promise.all(streams).then((tracks)=>{\r\n            let sessionPromises = [];\r\n            for (let session in this.sessions) {\r\n                sessionPromises.push(this.sessions[session].start());\r\n            }\r\n            return Promise.all(sessionPromises).then(()=>{\r\n                if (this.ontracks) {\r\n                    this.ontracks(tracks);\r\n                }\r\n            })\r\n        }).catch((e)=>{\r\n            console.error(e);\r\n            this.stop();\r\n            this.reset();\r\n        });\r\n    }\r\n\r\n    onSetup() {\r\n        this.transitionTo(RTSPClientSM.STATE_STREAMS);\r\n    }\r\n\r\n    onRTP(_data) {\r\n        if (!this.rtpFactory) return;\r\n\r\n        let rtp = this.rtpFactory.build(_data.packet, this.sdp);\r\n        if (!rtp.type) {\r\n            return;\r\n        }\r\n\r\n        if (this.timeOffset[rtp.pt] === undefined) {\r\n            //console.log(rtp.pt, this.timeOffset[rtp.pt]);\r\n            this.rtpBuffer[rtp.pt].push(rtp);\r\n            return;\r\n        }\r\n\r\n        if (this.lastTimestamp[rtp.pt] === undefined) {\r\n            this.lastTimestamp[rtp.pt] = rtp.timestamp-this.timeOffset[rtp.pt];\r\n        }\r\n\r\n        let queue = this.rtpBuffer[rtp.pt];\r\n        queue.push(rtp);\r\n\r\n        while (queue.length) {\r\n            let rtp = queue.shift();\r\n\r\n            rtp.timestamp = rtp.timestamp-this.timeOffset[rtp.pt]-this.lastTimestamp[rtp.pt];\r\n            // TODO: overflow\r\n            // if (rtp.timestamp < 0) {\r\n            //     rtp.timestamp = (rtp.timestamp + Number.MAX_SAFE_INTEGER) % 0x7fffffff;\r\n            // }\r\n            if (rtp.media) {\r\n                let pay = this.payParser.parse(rtp);\r\n                if (pay) {\r\n                    // if (typeof pay == typeof []) {\r\n                    this.parent.sampleQueues[rtp.type].push(pay);\r\n                    // } else {\r\n                    //     this.parent.sampleQueues[rtp.type].push([pay]);\r\n                    // }\r\n                } else {\r\n                    // this.parent.sampleQueues[rtp.type].push(pay);\r\n                }\r\n            }\r\n        }\r\n        // this.remuxer.feedRTP();\r\n    }\r\n}"],"names":[],"mappings":";;;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCgDI;;;;;;;UAOI;;mBAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECzDJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCkDI;;;;;;;;;;;qBAWe;;;mBAGf;;MAEA;;;;;UAKI;;mBAEJ;;MAEA;;;cAGQ;;;;;mBAKR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC4HA;;;UAGI;UACA;mBACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwCA;;;;;;;;;;;;;;;;kBAgBY;kBACA;;;cAGJ;;;;;;;mBAOR;;MAEA;;UAEI;;cAEI;;;;;mBAKR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsCA;;;kBAGY;;;;;;6BAMW;;;;;;;;;;;;;0BAaH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAmCpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECjYJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCsNI;;;kBAGY;;cAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBA4BI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA+BZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2DA;;;kBAGY;;cAEJ;;;cAGA;;;;;;;;;mBASR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCnJA;;;UAGI;UACA;mBACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAwCA;;;;;;;;;;;;;;;;kBAgBY;kBACA;;;cAGJ;;;;;;;mBAOR;;MAEA;;UAEI;;cAEI;;;;;mBAKR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsCA;;;kBAGY;;;;;;6BAMW;;;;;;;;;;;;;0BAaH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAmCpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}